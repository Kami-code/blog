<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>pointnet_and_related_works - Ryan &#039;s website</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ryan&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ryan&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"><meta property="og:type" content="blog"><meta property="og:title" content="pointnet_and_related_works"><meta property="og:url" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/"><meta property="og:site_name" content="Ryan &#039;s website"><meta property="og:description" content="​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222210517514.png"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222211120661.png"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211224164623985.png"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211227141149422.png"><meta property="og:image" content="https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211224120642649.png"><meta property="article:published_time" content="2021-12-22T12:03:50.000Z"><meta property="article:modified_time" content="2022-01-17T17:06:34.136Z"><meta property="article:author" content="Kami-code"><meta property="article:tag" content="VoteNet"><meta property="article:tag" content="PointNet"><meta property="article:tag" content="PointNet++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kami-code.com/2021/12/22/pointnet-and-related-works/"},"headline":"pointnet_and_related_works","image":["https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222201113122.png","https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222210517514.png","https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211222211120661.png","https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211224164623985.png","https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211227141149422.png","https://kami-code.com/2021/12/22/pointnet-and-related-works/image-20211224120642649.png"],"datePublished":"2021-12-22T12:03:50.000Z","dateModified":"2022-01-17T17:06:34.136Z","author":{"@type":"Person","name":"Kami-code"},"publisher":{"@type":"Organization","name":"Ryan 's website","logo":{"@type":"ImageObject","url":"https://kami-code.com/img/logo.svg"}},"description":"​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"}</script><link rel="canonical" href="https://kami-code.com/2021/12/22/pointnet-and-related-works/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ryan &#039;s website" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-22T12:03:50.000Z" title="2021/12/22 下午8:03:50">2021-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-17T17:06:34.136Z" title="2022/1/18 上午1:06:34">2022-01-18</time></span><span class="level-item">28 minutes read (About 4180 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">pointnet_and_related_works</h1><div class="content"><p>​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fq4y127k3">讲解视频</a></p>
<span id="more"></span>

<h1 id="PointNet"><a href="#PointNet" class="headerlink" title="PointNet"></a>PointNet</h1><p>​    PointNet一定是3D pointcloud perception的里程碑，保留了大道至简的美感的同时，给出了严格的证明。是从每个角度都应该称赞的作品。</p>
<p>​    正如原文所说，又是空间中的n个点的集合有如下特性：</p>
<ul>
<li><p>无序性（输出应当与输入的n个点的排序无关）</p>
</li>
<li><p>点和其邻居之间是有一些依赖关系的，我们设计的网络需要能够从邻居点中提取出局部特征</p>
</li>
<li><p>旋转和位移不变性（不过pointnet和pointnet++对旋转的处理都不是很好）</p>
<p>所以pointnet使用了max-pooling层来作为对称函数解决点云无序性的问题。</p>
<p><img src="/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"></p>
</li>
</ul>
<h2 id="PointNet的证明"><a href="#PointNet的证明" class="headerlink" title="PointNet的证明"></a>PointNet的证明</h2><p>​    我们令$\chi={S:S\subseteq[0,1]^m\text{and}|S|=n}$，此处的S就是我们的input，即一个欧式空间中的点集实例。此处做了归一化处理，所以它是模长恒定的m维向量。而$\chi$自然就是欧式空间中的点集的集合。我们希望拟合一个定义在集合上的连续函数$f:\chi\rightarrow\mathbb{R}$，注意此处的$\mathbb{R}$是指实数空间，而不是实数。</p>
<p>​    因为这个函数是连续函数，所以在点集$S,S’\in\chi$上有如下性质：<br>$$<br>\forall\varepsilon&gt;0,\exist\delta&gt;0 \\<br>\textbf{if } d_h(S,S’)&lt;\delta \\<br>\textbf{then} |f(S)-f(S’)|&lt;\varepsilon<br>$$<br>​    其中的$d_h$其实就是集合距离（豪斯多夫距离），我们只需要把上述认为是普通函数连续性的推广即可。</p>
<p>​    对于PointNet来说，它得到的拟合出来的函数的形式是：$\gamma(\mathop{MAX}_{x_i\in S}{h(x_i)})$。其中，我们令$S={x_1,x_2,…,x_n}$，其中$x_i\in R^N$，比如说我们单纯的空间位置的话，那就是$N=3$，而$h(x_i)$其实就是对这n个点做shared-MLP，得到的结果做一个maxpooling出一个$1\times1024$维的global feature。然后$\gamma$其实就是最后处理global feature的MLP。</p>
<p>​    我们需要证明的就是<br>$$<br>\forall\varepsilon&gt;0,\exist \text{ such a function} \\<br>\textbf{then} |f(S)-\gamma(\mathop{MAX}_{x_i\in S}{h(x_i)})|&lt;\varepsilon<br>$$</p>
<h2 id="相对直观的分析"><a href="#相对直观的分析" class="headerlink" title="相对直观的分析"></a>相对直观的分析</h2><p>​    我们可以简单地认为$h(·)$就是把$x_i$映射到空间网格中的一个格子里，我们记这个空间网格的大小为$M\times M\times M$。那么因为点只会映射到一个网格中，我们可以得到$h(x_i)$就是一个大小为$1\times M^3$的向量，并且只有一个值为1，其余值为0。</p>
<img src="/2021/12/22/pointnet-and-related-works/image-20211222210517514.png" style="zoom:50%;">

<p>而MAX函数我们可以认为是使用空间网格来重建我们的输入点云，我们可以令这个网格足够密集（M足够大），使得每个网格至多包含一个原先的点，这样就等于我们做完max-pooling后，得到了一个$1\times M^3$的向量，其中有n个点为1，其余为0。</p>
<img src="/2021/12/22/pointnet-and-related-works/image-20211222211120661.png" style="zoom:80%;">

<p>​    因为网格的密度可以足够大，所以我们可以使用网格模型以任意精度去近似我们原先的点云集合$S$。接下来的$\gamma$其实就是对这个新的表示形式的$1\times M^3$向量(global feature)去做一个MLP。因为MLP可以近似任意函数，那它自然也能近似$f$函数，得证。本证明过程参考了深蓝学院的<a target="_blank" rel="noopener" href="https://www.shenlanxueyuan.com/course/347/task/9996/show">点云课程</a>。</p>
<h2 id="论文中的纯数学分析"><a href="#论文中的纯数学分析" class="headerlink" title="论文中的纯数学分析"></a>论文中的纯数学分析</h2><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27136953/article/details/109960161">CSDN</a>。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138522402">知乎</a>。</p>
<h1 id="PointNet-1"><a href="#PointNet-1" class="headerlink" title="PointNet++"></a>PointNet++</h1><p>​    PointNet只使用一个max-pooling层来整合全局信息，而PointNet++使用层级结构来逐层提取特征，并且不断地从层级中抽象出更大的局部区域。在PointNet++中，主要是通过set abstraction layer来实现的，它包含了sampling layer（最远点采样）, grouping layer和PointNet layer。</p>
<img src="/2021/12/22/pointnet-and-related-works/image-20211224164623985.png" style="zoom:67%;">

<h2 id="Sampling-Layer"><a href="#Sampling-Layer" class="headerlink" title="Sampling Layer"></a>Sampling Layer</h2><p>​    其实这一部分就是一个最远点采样的工作。也就是输入的维度是$B\times N \times(C+D)$，通常情况下$C=3$，而$D$就是特征维度，并且我们已知当前层需要采样到$\text{npoints}$个点。那么其实就是$B\times N \times (C+D)\rightarrow B\times\text{npoints}\times(C+D)$。</p>
<h2 id="Grouping-Layer"><a href="#Grouping-Layer" class="headerlink" title="Grouping Layer"></a>Grouping Layer</h2><p>​    这个层的目标是找到每个点的邻居，其实就是从半径为$r$的球中找到至多$\text{nsample}$个元素。</p>
<h2 id="PointNet-Layer"><a href="#PointNet-Layer" class="headerlink" title="PointNet Layer"></a>PointNet Layer</h2><p>​    这个其实就是拿原先的PointNet来提取特征。</p>
<h3 id="Set-Abstraction-Layer的MSG优化"><a href="#Set-Abstraction-Layer的MSG优化" class="headerlink" title="Set Abstraction Layer的MSG优化"></a>Set Abstraction Layer的MSG优化</h3><p><img src="/2021/12/22/pointnet-and-related-works/image-20211227141149422.png"></p>
<p>​    因为原先的set abstraction layer是在固定的一个半径上去做的，感受野是固定大小。而MSG就是在多个不同的半径上去提取特征，最后组合在一起。</p>
<h3 id="Point-Feature-Propagation"><a href="#Point-Feature-Propagation" class="headerlink" title="Point Feature Propagation"></a>Point Feature Propagation</h3><p>​    在set abstraction layer中，原先的点集被降采样了。然而在点分割任务中，我们需要对每个点获取到一个点的种类标签，所以我们希望得到原先所有点的一个特征。一个方法就是在set abstraction layer中，我们永远采样所有的点作为中心点，但是这会导致计算消耗非常大，另一个方法就是使用point feature propagation。</p>
<p>​    在feature propagation layer中，它的输入是$N_i\times(d+C)$，而它的输出的$N_{i-1}\times(d+C)$，注意到其中的$N_i$就是在每层的set abstraction layer中的大小。所以其实这就是一个Decoder，并且在每一层Decode得到了全局特征后，再拼上了原先set abstraction layer的局部特征。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    接下来我们尝试来理解PointNet++的源码，PointNet++提供了三种任务的代码：classification、part segmentation和semantic segmentation，而set abstraction layer分为了SSG(single-scale grouping)和MSG(multi-scale grouping)。通常有<a target="_blank" rel="noopener" href="https://github.com/yanx27/Pointnet_Pointnet2_pytorch">纯Python版本的Pytorch实现</a>和<a target="_blank" rel="noopener" href="https://github.com/erikwijmans/Pointnet2_PyTorch">带有Cuda实现功能函数的Pytorch实现</a>，因为最原先开源的版本是Tensorflow版本，这两个Pytorch版本在变量命名上都借鉴了原先版本的命名，但是这和论文中的参数命名是一个都对不上。并且个别出出现了破坏软件抽象规则的地方，如在PointNetSetAbstractionMsg中调用了类似于sample_and_group的结构但并没有复用代码，亦或者sample_and_group_all其实可以规约到sample_and_group，但是又重新写了一个函数等一系列问题。所以总体代码看起来比较痛苦，不过当我们彻底搞清楚代码以后，我们就可以把PoineNet++当做开箱即用的东西，再也不管它的底层实现了。</p>
<h3 id="sample-and-group的实现"><a href="#sample-and-group的实现" class="headerlink" title="sample_and_group的实现"></a>sample_and_group的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_and_group</span>(<span class="params">npoint, radius, nsample, xyz, features, returnfps=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        npoint:	N_&#123;i+1&#125;</span></span><br><span class="line"><span class="string">        radius:	查询半径</span></span><br><span class="line"><span class="string">        nsample: 考察至多几个邻域中的点</span></span><br><span class="line"><span class="string">        xyz: input points position data, [B, N, 3]</span></span><br><span class="line"><span class="string">        features: input points feature data, [B, N, C]</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        new_xyz: sampled points position data, [B, npoint, nsample, 3]</span></span><br><span class="line"><span class="string">        new_FEATURES: sampled points feature data, [B, npoint, nsample, 3+D]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B, N, d = xyz.shape	<span class="comment"># d = 3</span></span><br><span class="line">    fps_idx = farthest_point_sample(xyz, npoint)	</span><br><span class="line">    <span class="comment"># 最远点采样，从N_&#123;i&#125;个点中选出N_&#123;i+1&#125;个作为中心点</span></span><br><span class="line">    new_xyz = index_points(xyz, fps_idx)    <span class="comment"># [B, N_i, 3] -&gt; [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line">    idx = query_ball_point(radius, nsample, xyz, new_xyz)</span><br><span class="line">    grouped_xyz = index_points(xyz, idx) 	<span class="comment"># [B, N_&#123;i+1&#125;, nsample, 3]</span></span><br><span class="line">    grouped_xyz_norm = grouped_xyz - new_xyz.view(B, npoint, <span class="number">1</span>, d)	</span><br><span class="line">    <span class="comment"># 此处的new_xyz先变为[B, N_&#123;i+1&#125;, 1, d]，然后加减法自动repeat，最终得到 [B, N_&#123;i+1&#125;, nsample, 3]</span></span><br><span class="line">    <span class="comment"># 此处就是把所有得到的点都转化为了相对于中心点的位置。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> features <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        grouped_features = index_points(features, idx)	<span class="comment"># [B, N_&#123;i+1&#125;, nsample, C_i]</span></span><br><span class="line">        new_features = torch.cat([grouped_xyz_norm, grouped_features], dim=-<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># [B, N_&#123;i+1&#125;, nsample, 3+C_i]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_features = grouped_xyz_norm</span><br><span class="line">    <span class="keyword">if</span> returnfps:</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features, grouped_xyz, fps_idx</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features</span><br><span class="line">    <span class="comment"># new_xyz = 		[B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3]</span></span><br><span class="line">    <span class="comment"># new_features = 	[B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3+C_i]</span></span><br></pre></td></tr></table></figure>

<h3 id="query-ball-point的实现"><a href="#query-ball-point的实现" class="headerlink" title="query_ball_point的实现"></a>query_ball_point的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_ball_point</span>(<span class="params">radius, K, xyz, new_xyz</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        radius: local region radius</span></span><br><span class="line"><span class="string">        nsample: max sample number in local region，注意这个邻居是要在原先的N_i个点中找的。</span></span><br><span class="line"><span class="string">        xyz: all points, [B, N_i, 3]</span></span><br><span class="line"><span class="string">        new_xyz: query points, [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        group_idx: grouped points index, [B, N_&#123;i+1&#125;, K]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    device = xyz.device</span><br><span class="line">    B, N, C = xyz.shape</span><br><span class="line">    _, npoint, _ = new_xyz.shape</span><br><span class="line">    group_idx = torch.arange(N, dtype=torch.long).to(device).view(<span class="number">1</span>, <span class="number">1</span>, N).repeat([B, npoint, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 每个S（中心点）都有一个向量[1, 2, 3, ..., N]，如果这个向量里的值为N，那么就是不在中心点的邻域里；如果向量值等于自己，就是在中心点的邻域里</span></span><br><span class="line">    <span class="comment"># 此时我们得到group_idex = [B * N_&#123;i+1&#125; * N_&#123;i&#125;]</span></span><br><span class="line">    sqrdists = square_distance(new_xyz, xyz)    <span class="comment"># 输出的大小为 [B, N_&#123;i+1&#125;, N_&#123;i&#125;]，每个[N_&#123;i+1&#125;, N_&#123;i&#125;]里记录了两个点之间的距离</span></span><br><span class="line">    group_idx[sqrdists &gt; radius ** <span class="number">2</span>] = N       <span class="comment"># 那些半径不满足条件的索引值都设置为N</span></span><br><span class="line">    group_idx = group_idx.sort(dim=-<span class="number">1</span>)[<span class="number">0</span>][:, :, :K]   <span class="comment"># 按照序号从小到大排，eg:[1, 3, 4, 5, ..., N, N, N]</span></span><br><span class="line">    <span class="comment"># 排完序后取前K个，那也就是[B, N_&#123;i+1&#125;, K]，意思就是每个中心点都对应了K个邻居的序号。</span></span><br><span class="line">    group_first = group_idx[:, :, <span class="number">0</span>].view(B, S, <span class="number">1</span>).repeat([<span class="number">1</span>, <span class="number">1</span>, K])</span><br><span class="line">    mask = group_idx == N</span><br><span class="line">    group_idx[mask] = group_first[mask]</span><br><span class="line">    <span class="comment"># 对于每个中心点的满足半径的邻居可能少于K个的情况，全部用第一个邻居的序号来替代。</span></span><br><span class="line">    <span class="keyword">return</span> group_idx</span><br></pre></td></tr></table></figure>

<h3 id="Classificaction-Task"><a href="#Classificaction-Task" class="headerlink" title="Classificaction Task"></a>Classificaction Task</h3><p>​    这一部分其实就是论文中的这个结构：</p>
<img src="/2021/12/22/pointnet-and-related-works/image-20211224120642649.png" style="zoom:67%;">

<p>​    我们注意到在实现中有$N_1=512,N_2=128$，$d=3$是点云的欧式空间坐标，如果点云输入有法向量数据，那么$C=3$，否则$C=0$。并且中间层有$C_1=128,C_2=256，C_4=1024,k=\text{num_class}$，在数据集modelnet40下，$k=\text{num_class}=40$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get_model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_class,normal_channel=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(get_model, self).__init__()</span><br><span class="line">        in_channel = <span class="number">6</span> <span class="keyword">if</span> normal_channel <span class="keyword">else</span> <span class="number">3</span></span><br><span class="line">        self.normal_channel = normal_channel</span><br><span class="line">        self.sa1 = PointNetSetAbstraction(npoint=<span class="number">512</span>, radius=<span class="number">0.2</span>, K=<span class="number">32</span>, in_channel=in_channel, mlp=[<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], group_all=<span class="literal">False</span>)</span><br><span class="line">        self.sa2 = PointNetSetAbstraction(npoint=<span class="number">128</span>, radius=<span class="number">0.4</span>, K=<span class="number">64</span>, in_channel=<span class="number">128</span> + <span class="number">3</span>, mlp=[<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>], group_all=<span class="literal">False</span>)</span><br><span class="line">        self.sa3 = PointNetSetAbstraction(npoint=<span class="literal">None</span>, radius=<span class="literal">None</span>, K=<span class="literal">None</span>, in_channel=<span class="number">256</span> + <span class="number">3</span>, mlp=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>], group_all=<span class="literal">True</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm1d(<span class="number">512</span>)</span><br><span class="line">        self.drop1 = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm1d(<span class="number">256</span>)</span><br><span class="line">        self.drop2 = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">256</span>, num_class)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz</span>):</span>	<span class="comment">#xyz = [B, 3+ C(0 or 3), N_0]</span></span><br><span class="line">        B, _, _ = xyz.shape</span><br><span class="line">        <span class="keyword">if</span> self.normal_channel:</span><br><span class="line">            norm = xyz[:, <span class="number">3</span>:, :]	<span class="comment"># norm = [B, 0 or 3, N_0] (如果用到了法向量)</span></span><br><span class="line">            xyz = xyz[:, :<span class="number">3</span>, :]		<span class="comment"># xyz = [B, 3, N_0]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            norm = <span class="literal">None</span></span><br><span class="line">        l1_xyz, l1_features = self.sa1(xyz, norm)	</span><br><span class="line">        <span class="comment"># l1_xyz = [B, 3, 512], l1_features = [B, 128, 512]</span></span><br><span class="line">        l2_xyz, l2_features = self.sa2(l1_xyz, l1_features)</span><br><span class="line">        <span class="comment"># l2_xyz = [B, 3, 128], l1_features = [B, 256, 128]</span></span><br><span class="line">        l3_xyz, l3_features = self.sa3(l2_xyz, l2_features)</span><br><span class="line">        <span class="comment"># l3_xyz = [B, 1, 3], l3_features = [B, 1, 1024]</span></span><br><span class="line">        <span class="comment"># 如果只是利用PointNet++提取特征的话，这样就可以了</span></span><br><span class="line">        x = l3_features.view(B, <span class="number">1024</span>)</span><br><span class="line">        x = self.drop1(F.relu(self.bn1(self.fc1(x))))	<span class="comment"># [B, 1024] -&gt; [B, 512]</span></span><br><span class="line">        x = self.drop2(F.relu(self.bn2(self.fc2(x))))	<span class="comment"># [B, 512] -&gt; [B, 256]</span></span><br><span class="line">        x = self.fc3(x)									<span class="comment"># [B, 256] -&gt; [B, 40]</span></span><br><span class="line">        x = F.log_softmax(x, -<span class="number">1</span>)	</span><br><span class="line">        <span class="keyword">return</span> x, l3_features</span><br></pre></td></tr></table></figure>

<p>​    接下来其实就是看set abstraction模块了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNetSetAbstraction</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, npoint, radius, K, in_channel, mlp, group_all</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PointNetSetAbstraction, self).__init__()</span><br><span class="line">        self.npoint = npoint</span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.K = K</span><br><span class="line">        self.mlp_convs = nn.ModuleList()</span><br><span class="line">        self.mlp_bns = nn.ModuleList()</span><br><span class="line">        last_channel = in_channel</span><br><span class="line">        <span class="keyword">for</span> out_channel <span class="keyword">in</span> mlp:</span><br><span class="line">            self.mlp_convs.append(nn.Conv2d(last_channel, out_channel, <span class="number">1</span>))	<span class="comment"># 卷积核大小为1</span></span><br><span class="line">            self.mlp_bns.append(nn.BatchNorm2d(out_channel))</span><br><span class="line">            last_channel = out_channel</span><br><span class="line">        <span class="comment"># 对于sa1来说，就是有 3个MLP层，每层的卷积核大小都是1*1</span></span><br><span class="line">        <span class="comment"># 第一层 [B, 3+C_i, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 第二层 [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 第三层 [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 128, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            </span><br><span class="line">        self.group_all = group_all</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Input:</span></span><br><span class="line"><span class="string">            xyz: input points position data, [B, 3, N_i]</span></span><br><span class="line"><span class="string">            features: input points feature data, [B, C_i, N_i]</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            new_xyz: sampled points position data, [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">            new_features: sample points feature data, [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xyz = xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> features <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            features = features.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.group_all:</span><br><span class="line">            new_xyz, new_features = sample_and_group_all(xyz, features)</span><br><span class="line">            <span class="comment"># new_xyz = [B, 1, 3]</span></span><br><span class="line">            <span class="comment"># new_features = [B, 1, K_&#123;i+1&#125;, 3+C_i]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_xyz, new_features = sample_and_group(self.npoint, self.radius, self.K, xyz, features)</span><br><span class="line">        <span class="comment"># new_xyz: sampled points position data, [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line">        <span class="comment"># new_features: sampled points position and feature data, [B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3+C_i]</span></span><br><span class="line">        new_features_concat = new_points.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># [B, 3+C_i, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.mlp_convs):</span><br><span class="line">            bn = self.mlp_bns[i]</span><br><span class="line">            new_features_concat = F.relu(bn(conv(new_features_concat)))</span><br><span class="line">        <span class="comment"># [B, C_&#123;i+1&#125;, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">		</span><br><span class="line">        new_features_concat = torch.<span class="built_in">max</span>(new_features_concat, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># [B, C_&#123;i+1&#125;, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 其实就是说从邻域特征中找到一个最大响应的值，因为每次处理的邻域的半径不同，所以每次提取特征响应的感受野也不同，实现了不同尺度下的特征提取</span></span><br><span class="line">        new_xyz = new_xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># [B, N_&#123;i+1&#125;, 3] -&gt; [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features_concat	</span><br></pre></td></tr></table></figure>

<p>​    对于set abstraction layer来说，它的输入是$B\times N_{i} \times (3+C_i)$，而它的输出是$B\times N_{i+1}\times(3+C_{i+1})$。</p>
<p>​    理论上这样我们的分类任务已经可以完成了，这也是SSG(single-scale grouping)的情况。我们需要再看一下论文所提出的MSG的set abstraction module是如何实现的。</p>
<p>​    我们可以看到models里总体架构没有变，唯一有区别的就是两个sa层变为了SA_MSG。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.sa1 = PointNetSetAbstractionMsg(npoint=<span class="number">512</span>, radius_list=[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>], K_list=[<span class="number">16</span>, <span class="number">32</span>, <span class="number">128</span>], in_channel=in_channel, mlp_list=[[<span class="number">32</span>, <span class="number">32</span>, <span class="number">64</span>], [<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], [<span class="number">64</span>, <span class="number">96</span>, <span class="number">128</span>]])</span><br><span class="line">self.sa2 = PointNetSetAbstractionMsg(npoint=<span class="number">128</span>, radius_list=[<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>], K_list=[<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>], in_channel=<span class="number">320</span>, mlp_list=[[<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>]])</span><br><span class="line">self.sa3 = PointNetSetAbstraction(npoint=<span class="literal">None</span>, radius=<span class="literal">None</span>, K=<span class="literal">None</span>, in_channel=<span class="number">640</span> + <span class="number">3</span>, mlp=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>], group_all=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>​    其实我们只要搞明白上述的in_channel各自是怎么来的。以sa2的in_channel为例：<br>$$<br>\text{in_channel}=320=\Sigma_j(\text{out_channel}_j)=64+128+128<br>$$<br>​    这样我们就明白了，其实就是把不同的radius所提取的不同尺度的特征拼接在一起得到320维的特征向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNetSetAbstractionMsg</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, npoint, radius_list, K_list, in_channel, mlp_list</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PointNetSetAbstractionMsg, self).__init__()</span><br><span class="line">        self.npoint = npoint</span><br><span class="line">        self.radius_list = radius_list</span><br><span class="line">        self.nsample_list = nsample_list</span><br><span class="line">        self.conv_blocks = nn.ModuleList()</span><br><span class="line">        self.bn_blocks = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mlp_list)):</span><br><span class="line">            convs = nn.ModuleList()</span><br><span class="line">            bns = nn.ModuleList()</span><br><span class="line">            last_channel = in_channel + <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> out_channel <span class="keyword">in</span> mlp_list[i]:</span><br><span class="line">                convs.append(nn.Conv2d(last_channel, out_channel, <span class="number">1</span>))</span><br><span class="line">                bns.append(nn.BatchNorm2d(out_channel))</span><br><span class="line">                last_channel = out_channel</span><br><span class="line">            self.conv_blocks.append(convs)</span><br><span class="line">            self.bn_blocks.append(bns)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Input:</span></span><br><span class="line"><span class="string">            xyz: input points position data, [B, 3, N_i]</span></span><br><span class="line"><span class="string">            points: input points data, [B, C_i, N_i]</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            new_xyz: sampled points position data, [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">            new_points_concat: sample points feature data, [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xyz = xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)   <span class="comment"># [B, N_i, 3]</span></span><br><span class="line">        <span class="keyword">if</span> points <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            points = points.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)    <span class="comment"># [B, N, C_i] ,C_i就是每个点额外的特征向量</span></span><br><span class="line"></span><br><span class="line">        B, N, C = xyz.shape</span><br><span class="line">        new_xyz = index_points(xyz, farthest_point_sample(xyz, self.npoint))  <span class="comment"># [B, N_&#123;i+1&#125;, C_i]</span></span><br><span class="line">        new_points_list = []</span><br><span class="line">        <span class="keyword">for</span> j, radius <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.radius_list):   <span class="comment"># 在不同的尺度下找ball query，枚举radius_list</span></span><br><span class="line">            K = self.nsample_list[j]    				<span class="comment"># 当前半径下，中心节点的邻居的数量</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ======================以下开始其实是sample_and_group的逻辑====================</span></span><br><span class="line">            group_idx = query_ball_point(radius, K, xyz, new_xyz)   </span><br><span class="line">            grouped_xyz = index_points(xyz, group_idx)  <span class="comment"># [B, 3, npoints, nsample]</span></span><br><span class="line">            grouped_xyz -= new_xyz.view(B, S, <span class="number">1</span>, C) <span class="comment"># ??? 转换成相对坐标</span></span><br><span class="line">            <span class="keyword">if</span> points <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                grouped_points = index_points(points, group_idx)</span><br><span class="line">                grouped_points = torch.cat([grouped_points, grouped_xyz], dim=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                grouped_points = grouped_xyz</span><br><span class="line">            <span class="comment"># ===========================================================================</span></span><br><span class="line"></span><br><span class="line">            grouped_points = grouped_points.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)  </span><br><span class="line">            <span class="comment"># [B, N_&#123;i+1&#125;, K_&#123;j&#125;, (3+D)] -&gt; [B, (3+D), K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.conv_blocks[j])):   </span><br><span class="line">                <span class="comment"># 所以mlp_list是一个二维数组，每一行都代表在对应半径下使用的input_channels</span></span><br><span class="line">                conv = self.conv_blocks[j][k]</span><br><span class="line">                bn = self.bn_blocks[j][k]</span><br><span class="line">                grouped_points = F.relu(bn(conv(grouped_points))) </span><br><span class="line">                <span class="comment"># 得到了 [B, out_channel_j, K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            <span class="comment"># 最终我们得到一个group_points, [B, out_channel_j, K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            new_points = torch.<span class="built_in">max</span>(grouped_points, <span class="number">2</span>)[<span class="number">0</span>]  <span class="comment"># [B, out_channel_j, N_&#123;i+1&#125;]</span></span><br><span class="line">            new_points_list.append(new_points)</span><br><span class="line">        <span class="comment"># 最终new_points_list为 len_radius_list 个 [B, out_channel_j, N_&#123;i+1&#125;]</span></span><br><span class="line"></span><br><span class="line">        new_xyz = new_xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        new_points_concat = torch.cat(new_points_list, dim=<span class="number">1</span>)   <span class="comment"># 最终得到 [B, sigma&#123;out_channel_j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;new_points_concat.size = &quot;</span>, new_points_concat)</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_points_concat</span><br></pre></td></tr></table></figure>



<p>Q：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266324173">PointNet++梯度是如何回传的？？？</a></p>
<p>A：PointNet++ fps实际上并没有参与梯度计算和反向传播。</p>
<p>可以理解成是PointNet++将点云进行不同规模的fps降采样，事先将这些数据准备好，再送到网络中去训练。</p>
<h1 id="VoteNet"><a href="#VoteNet" class="headerlink" title="VoteNet"></a>VoteNet</h1><p>​    VoteNet是基于end-to-end的3D目标检测网络，它基于3D的深度点云网络和霍夫投票。</p>
<p>​    可以从<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fq4y127k3">讲解视频</a>和<a target="_blank" rel="noopener" href="https://www.kami-code.com/2022/01/17/machine-learning-pre/">PPT</a>获得相关内容。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>pointnet_and_related_works</p><p><a href="https://kami-code.com/2021/12/22/pointnet-and-related-works/">https://kami-code.com/2021/12/22/pointnet-and-related-works/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Kami-code</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-12-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-01-18</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/VoteNet/">VoteNet</a><a class="link-muted mr-2" rel="tag" href="/tags/PointNet/">PointNet</a><a class="link-muted mr-2" rel="tag" href="/tags/PointNet/">PointNet++</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/17/machine-learning-pre/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">VoteNet_pre</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/12/20/screwnet/"><span class="level-item">(ICRA2021)ScrewNet</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="SOHUCS" sid="2021/12/22/pointnet-and-related-works/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cyvI88c19',conf: 'prod_634561f1ec380218934dcf2c12b8b70b'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Chen Bao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Chen Bao</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">34</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kami-code" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kami-code"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-06T16:03:57.933Z">2022-02-07</time></p><p class="title"><a href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E6%94%BB%E6%96%87%E6%A1%88/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-29T03:41:38.000Z">2022-01-29</time></p><p class="title"><a href="/2022/01/29/unigrasp/">unigrasp</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-26T10:59:39.000Z">2022-01-26</time></p><p class="title"><a href="/2022/01/26/GIGA/">(RSS2021)GIGA的仿真器部分</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-18T06:33:35.000Z">2022-01-18</time></p><p class="title"><a href="/2022/01/18/GraspNet-1Billion/">(CVPR2020)GraspNet-1Billion</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-17T07:07:22.000Z">2022-01-17</time></p><p class="title"><a href="/2022/01/17/6D-GraspNet/">(ICCV2019)6D-GraspNet</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/6D-GraspNet/"><span class="tag">6D-GraspNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CHOMP/"><span class="tag">CHOMP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CVPR/"><span class="tag">CVPR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Camera/"><span class="tag">Camera</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GraspNet/"><span class="tag">GraspNet</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ICCV/"><span class="tag">ICCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ICRA/"><span class="tag">ICRA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Neo4j/"><span class="tag">Neo4j</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenGL/"><span class="tag">OpenGL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PointNet/"><span class="tag">PointNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PointNet/"><span class="tag">PointNet++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pybind11/"><span class="tag">Pybind11</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pybullet/"><span class="tag">Pybullet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROS/"><span class="tag">ROS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RSS/"><span class="tag">RSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SE3353/"><span class="tag">SE3353</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ScrewNet/"><span class="tag">ScrewNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Search/"><span class="tag">Search</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VoteNet/"><span class="tag">VoteNet</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebService/"><span class="tag">WebService</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/behavior-tree/"><span class="tag">behavior tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compliers/"><span class="tag">compliers</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deeplearning/"><span class="tag">deeplearning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ikfast/"><span class="tag">ikfast</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lab/"><span class="tag">lab</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mmdection/"><span class="tag">mmdection</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/moveit/"><span class="tag">moveit</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/planning/"><span class="tag">planning</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pybullet/"><span class="tag">pybullet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/segmentation/"><span class="tag">segmentation</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ryan &#039;s website" height="28"></a><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><p class="is-size-7"><span>&copy; 2022 Kami-code</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>