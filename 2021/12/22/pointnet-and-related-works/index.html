<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>PointNet and related works - Ryan &#039;s website</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="Ryan&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ryan&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"><meta property="og:type" content="blog"><meta property="og:title" content="PointNet and related works"><meta property="og:url" content="https://kami-code.com/blog/2021/12/22/pointnet-and-related-works/"><meta property="og:site_name" content="Ryan &#039;s website"><meta property="og:description" content="​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222210517514.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222211120661.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224164623985.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211227141149422.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224120642649.png"><meta property="og:image" content="https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20220209002255184.png"><meta property="article:published_time" content="2021-12-22T12:03:50.000Z"><meta property="article:modified_time" content="2022-02-19T05:10:53.635Z"><meta property="article:author" content="Kami-code"><meta property="article:tag" content="VoteNet"><meta property="article:tag" content="PointNet"><meta property="article:tag" content="PointNet++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kami-code.com/blog/2021/12/22/pointnet-and-related-works/"},"headline":"PointNet and related works","image":["https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222201113122.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222210517514.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222211120661.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224164623985.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211227141149422.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224120642649.png","https://kami-code.com/blog/blog/2021/12/22/pointnet-and-related-works/image-20220209002255184.png"],"datePublished":"2021-12-22T12:03:50.000Z","dateModified":"2022-02-19T05:10:53.635Z","author":{"@type":"Person","name":"Kami-code"},"publisher":{"@type":"Organization","name":"Ryan 's website","logo":{"@type":"ImageObject","url":"https://kami-code.com/img/logo.svg"}},"description":"​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。讲解视频"}</script><link rel="canonical" href="https://kami-code.com/blog/2021/12/22/pointnet-and-related-works/"><link rel="icon" href="/blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/img/logo.svg" alt="Ryan &#039;s website" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">Home</a><a class="navbar-item" href="/blog/archives">Archives</a><a class="navbar-item" href="/blog/categories">Categories</a><a class="navbar-item" href="/blog/tags">Tags</a><a class="navbar-item" href="/blog/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-22T12:03:50.000Z" title="2021/12/22 下午8:03:50">2021-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-19T05:10:53.635Z" title="2022/2/19 下午1:10:53">2022-02-19</time></span><span class="level-item">an hour read (About 7566 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">PointNet and related works</h1><div class="content"><p>​    最近一门机器学习的课有一个阅读论文的作业，我选了老本行votenet，不过发现自己一些实现细节还是不过关。借着这个机会再从pointnet开始梳理一下思路并且解读一下源码。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fq4y127k3">讲解视频</a></p>
<span id="more"></span>

<h1 id="PointNet"><a href="#PointNet" class="headerlink" title="PointNet"></a>PointNet</h1><p>​    PointNet一定是3D pointcloud perception的里程碑，保留了大道至简的美感的同时，给出了严格的证明。是从每个角度都应该称赞的作品。</p>
<p>​    正如原文所说，又是空间中的n个点的集合有如下特性：</p>
<ul>
<li><p>无序性（输出应当与输入的n个点的排序无关）</p>
</li>
<li><p>点和其邻居之间是有一些依赖关系的，我们设计的网络需要能够从邻居点中提取出局部特征</p>
</li>
<li><p>旋转和位移不变性（不过pointnet和pointnet++对旋转的处理都不是很好）</p>
<p>所以pointnet使用了max-pooling层来作为对称函数解决点云无序性的问题。</p>
<p><img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222201113122.png"></p>
</li>
</ul>
<h2 id="PointNet的证明"><a href="#PointNet的证明" class="headerlink" title="PointNet的证明"></a>PointNet的证明</h2><p>​    我们令$\chi={S:S\subseteq[0,1]^m\text{and}|S|=n}$，此处的S就是我们的input，即一个欧式空间中的点集实例。此处做了归一化处理，所以它是模长恒定的m维向量。而$\chi$自然就是欧式空间中的点集的集合。我们希望拟合一个定义在集合上的连续函数$f:\chi\rightarrow\mathbb{R}$，注意此处的$\mathbb{R}$是指实数空间，而不是实数。</p>
<p>​    因为这个函数是连续函数，所以在点集$S,S’\in\chi$上有如下性质：<br>$$<br>\forall\varepsilon&gt;0,\exist\delta&gt;0 \\<br>\textbf{if } d_h(S,S’)&lt;\delta \\<br>\textbf{then} |f(S)-f(S’)|&lt;\varepsilon<br>$$<br>​    其中的$d_h$其实就是集合距离（豪斯多夫距离），我们只需要把上述认为是普通函数连续性的推广即可。</p>
<p>​    对于PointNet来说，它得到的拟合出来的函数的形式是：$\gamma(\mathop{MAX}_{x_i\in S}{h(x_i)})$。其中，我们令$S={x_1,x_2,…,x_n}$，其中$x_i\in R^N$，比如说我们单纯的空间位置的话，那就是$N=3$，而$h(x_i)$其实就是对这n个点做shared-MLP，得到的结果做一个maxpooling出一个$1\times1024$维的global feature。然后$\gamma$其实就是最后处理global feature的MLP。</p>
<p>​    我们需要证明的就是<br>$$<br>\forall\varepsilon&gt;0,\exist \text{ such a function} \\<br>\textbf{then} |f(S)-\gamma(\mathop{MAX}_{x_i\in S}{h(x_i)})|&lt;\varepsilon<br>$$</p>
<h2 id="相对直观的分析"><a href="#相对直观的分析" class="headerlink" title="相对直观的分析"></a>相对直观的分析</h2><p>​    我们可以简单地认为$h(·)$就是把$x_i$映射到空间网格中的一个格子里，我们记这个空间网格的大小为$M\times M\times M$。那么因为点只会映射到一个网格中，我们可以得到$h(x_i)$就是一个大小为$1\times M^3$的向量，并且只有一个值为1，其余值为0。</p>
<img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222210517514.png" style="zoom:50%;">

<p>而MAX函数我们可以认为是使用空间网格来重建我们的输入点云，我们可以令这个网格足够密集（M足够大），使得每个网格至多包含一个原先的点，这样就等于我们做完max-pooling后，得到了一个$1\times M^3$的向量，其中有n个点为1，其余为0。</p>
<img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211222211120661.png" style="zoom:80%;">

<p>​    因为网格的密度可以足够大，所以我们可以使用网格模型以任意精度去近似我们原先的点云集合$S$。接下来的$\gamma$其实就是对这个新的表示形式的$1\times M^3$向量(global feature)去做一个MLP。因为MLP可以近似任意函数，那它自然也能近似$f$函数，得证。本证明过程参考了深蓝学院的<a target="_blank" rel="noopener" href="https://www.shenlanxueyuan.com/course/347/task/9996/show">点云课程</a>。</p>
<h2 id="论文中的纯数学分析"><a href="#论文中的纯数学分析" class="headerlink" title="论文中的纯数学分析"></a>论文中的纯数学分析</h2><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27136953/article/details/109960161">CSDN</a>。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138522402">知乎</a>。</p>
<h1 id="PointNet-1"><a href="#PointNet-1" class="headerlink" title="PointNet++"></a>PointNet++</h1><p>​    PointNet只使用一个max-pooling层来整合全局信息，而PointNet++使用层级结构来逐层提取特征，并且不断地从层级中抽象出更大的局部区域。在PointNet++中，主要是通过set abstraction layer来实现的，它包含了sampling layer（最远点采样）, grouping layer和PointNet layer。</p>
<img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224164623985.png" style="zoom:67%;">

<h2 id="Sampling-Layer"><a href="#Sampling-Layer" class="headerlink" title="Sampling Layer"></a>Sampling Layer</h2><p>​    其实这一部分就是一个最远点采样的工作。也就是输入的维度是$B\times N \times(C+D)$，通常情况下$C=3$，而$D$就是特征维度，并且我们已知当前层需要采样到$\text{npoints}$个点。那么其实就是$B\times N \times (C+D)\rightarrow B\times\text{npoints}\times(C+D)$。</p>
<h2 id="Grouping-Layer"><a href="#Grouping-Layer" class="headerlink" title="Grouping Layer"></a>Grouping Layer</h2><p>​    这个层的目标是找到每个点的邻居，其实就是从半径为$r$的球中找到至多$\text{nsample}$个元素。</p>
<h2 id="PointNet-Layer"><a href="#PointNet-Layer" class="headerlink" title="PointNet Layer"></a>PointNet Layer</h2><p>​    这个其实就是拿原先的PointNet来提取特征。</p>
<h3 id="Set-Abstraction-Layer的MSG优化"><a href="#Set-Abstraction-Layer的MSG优化" class="headerlink" title="Set Abstraction Layer的MSG优化"></a>Set Abstraction Layer的MSG优化</h3><p><img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211227141149422.png"></p>
<p>​    因为原先的set abstraction layer是在固定的一个半径上去做的，感受野是固定大小。而MSG就是在多个不同的半径上去提取特征，最后组合在一起。</p>
<h3 id="Point-Feature-Propagation"><a href="#Point-Feature-Propagation" class="headerlink" title="Point Feature Propagation"></a>Point Feature Propagation</h3><p>​    在set abstraction layer中，原先的点集被降采样了。然而在点分割任务中，我们需要对每个点获取到一个点的种类标签，所以我们希望得到原先所有点的一个特征。一个方法就是在set abstraction layer中，我们永远采样所有的点作为中心点，但是这会导致计算消耗非常大，另一个方法就是使用point feature propagation。</p>
<p>​    在feature propagation layer中，它的输入是$N_i\times(d+C)$，而它的输出的$N_{i-1}\times(d+C)$，注意到其中的$N_i$就是在每层的set abstraction layer中的大小。所以其实这就是一个Decoder，并且在每一层Decode得到了全局特征后，再拼上了原先set abstraction layer的局部特征。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    接下来我们尝试来理解PointNet++的源码，PointNet++提供了三种任务的代码：classification、part segmentation和semantic segmentation，而set abstraction layer分为了SSG(single-scale grouping)和MSG(multi-scale grouping)。通常有<a target="_blank" rel="noopener" href="https://github.com/yanx27/Pointnet_Pointnet2_pytorch">纯Python版本的Pytorch实现</a>和<a target="_blank" rel="noopener" href="https://github.com/erikwijmans/Pointnet2_PyTorch">带有Cuda实现功能函数的Pytorch实现</a>，因为最原先开源的版本是Tensorflow版本，这两个Pytorch版本在变量命名上都借鉴了原先版本的命名，但是这和论文中的参数命名是一个都对不上。并且个别出出现了破坏软件抽象规则的地方，如在PointNetSetAbstractionMsg中调用了类似于sample_and_group的结构但并没有复用代码，亦或者sample_and_group_all其实可以规约到sample_and_group，但是又重新写了一个函数等一系列问题。所以总体代码看起来比较痛苦，不过当我们彻底搞清楚代码以后，我们就可以把PoineNet++当做开箱即用的东西，再也不管它的底层实现了。</p>
<h3 id="sample-and-group的实现"><a href="#sample-and-group的实现" class="headerlink" title="sample_and_group的实现"></a>sample_and_group的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_and_group</span>(<span class="params">npoint, radius, nsample, xyz, features, returnfps=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        npoint:	N_&#123;i+1&#125;</span></span><br><span class="line"><span class="string">        radius:	查询半径</span></span><br><span class="line"><span class="string">        nsample: 考察至多几个邻域中的点</span></span><br><span class="line"><span class="string">        xyz: input points position data, [B, N, 3]</span></span><br><span class="line"><span class="string">        features: input points feature data, [B, N, C]</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        new_xyz: sampled points position data, [B, npoint, nsample, 3]</span></span><br><span class="line"><span class="string">        new_FEATURES: sampled points feature data, [B, npoint, nsample, 3+D]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B, N, d = xyz.shape	<span class="comment"># d = 3</span></span><br><span class="line">    fps_idx = farthest_point_sample(xyz, npoint)	</span><br><span class="line">    <span class="comment"># 最远点采样，从N_&#123;i&#125;个点中选出N_&#123;i+1&#125;个作为中心点</span></span><br><span class="line">    new_xyz = index_points(xyz, fps_idx)    <span class="comment"># [B, N_i, 3] -&gt; [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line">    idx = query_ball_point(radius, nsample, xyz, new_xyz)</span><br><span class="line">    grouped_xyz = index_points(xyz, idx) 	<span class="comment"># [B, N_&#123;i+1&#125;, nsample, 3]</span></span><br><span class="line">    grouped_xyz_norm = grouped_xyz - new_xyz.view(B, npoint, <span class="number">1</span>, d)	</span><br><span class="line">    <span class="comment"># 此处的new_xyz先变为[B, N_&#123;i+1&#125;, 1, d]，然后加减法自动repeat，最终得到 [B, N_&#123;i+1&#125;, nsample, 3]</span></span><br><span class="line">    <span class="comment"># 此处就是把所有得到的点都转化为了相对于中心点的位置。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> features <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        grouped_features = index_points(features, idx)	<span class="comment"># [B, N_&#123;i+1&#125;, nsample, C_i]</span></span><br><span class="line">        new_features = torch.cat([grouped_xyz_norm, grouped_features], dim=-<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># [B, N_&#123;i+1&#125;, nsample, 3+C_i]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_features = grouped_xyz_norm</span><br><span class="line">    <span class="keyword">if</span> returnfps:</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features, grouped_xyz, fps_idx</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features</span><br><span class="line">    <span class="comment"># new_xyz = 		[B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3]</span></span><br><span class="line">    <span class="comment"># new_features = 	[B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3+C_i]</span></span><br></pre></td></tr></table></figure>

<h3 id="query-ball-point的实现"><a href="#query-ball-point的实现" class="headerlink" title="query_ball_point的实现"></a>query_ball_point的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_ball_point</span>(<span class="params">radius, K, xyz, new_xyz</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        radius: local region radius</span></span><br><span class="line"><span class="string">        nsample: max sample number in local region，注意这个邻居是要在原先的N_i个点中找的。</span></span><br><span class="line"><span class="string">        xyz: all points, [B, N_i, 3]</span></span><br><span class="line"><span class="string">        new_xyz: query points, [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        group_idx: grouped points index, [B, N_&#123;i+1&#125;, K]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    device = xyz.device</span><br><span class="line">    B, N, C = xyz.shape</span><br><span class="line">    _, npoint, _ = new_xyz.shape</span><br><span class="line">    group_idx = torch.arange(N, dtype=torch.long).to(device).view(<span class="number">1</span>, <span class="number">1</span>, N).repeat([B, npoint, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 每个S（中心点）都有一个向量[1, 2, 3, ..., N]，如果这个向量里的值为N，那么就是不在中心点的邻域里；如果向量值等于自己，就是在中心点的邻域里</span></span><br><span class="line">    <span class="comment"># 此时我们得到group_idex = [B * N_&#123;i+1&#125; * N_&#123;i&#125;]</span></span><br><span class="line">    sqrdists = square_distance(new_xyz, xyz)    <span class="comment"># 输出的大小为 [B, N_&#123;i+1&#125;, N_&#123;i&#125;]，每个[N_&#123;i+1&#125;, N_&#123;i&#125;]里记录了两个点之间的距离</span></span><br><span class="line">    group_idx[sqrdists &gt; radius ** <span class="number">2</span>] = N       <span class="comment"># 那些半径不满足条件的索引值都设置为N</span></span><br><span class="line">    group_idx = group_idx.sort(dim=-<span class="number">1</span>)[<span class="number">0</span>][:, :, :K]   <span class="comment"># 按照序号从小到大排，eg:[1, 3, 4, 5, ..., N, N, N]</span></span><br><span class="line">    <span class="comment"># 排完序后取前K个，那也就是[B, N_&#123;i+1&#125;, K]，意思就是每个中心点都对应了K个邻居的序号。</span></span><br><span class="line">    group_first = group_idx[:, :, <span class="number">0</span>].view(B, S, <span class="number">1</span>).repeat([<span class="number">1</span>, <span class="number">1</span>, K])</span><br><span class="line">    mask = group_idx == N</span><br><span class="line">    group_idx[mask] = group_first[mask]</span><br><span class="line">    <span class="comment"># 对于每个中心点的满足半径的邻居可能少于K个的情况，全部用第一个邻居的序号来替代。</span></span><br><span class="line">    <span class="keyword">return</span> group_idx</span><br></pre></td></tr></table></figure>

<h3 id="Classificaction-Task"><a href="#Classificaction-Task" class="headerlink" title="Classificaction Task"></a>Classificaction Task</h3><p>​    这一部分其实就是论文中的这个结构：</p>
<img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20211224120642649.png" style="zoom:67%;">

<p>​    我们注意到在实现中有$N_1=512,N_2=128$，$d=3$是点云的欧式空间坐标，如果点云输入有法向量数据，那么$C=3$，否则$C=0$。并且中间层有$C_1=128,C_2=256，C_4=1024,k=\text{num_class}$，在数据集modelnet40下，$k=\text{num_class}=40$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get_model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_class,normal_channel=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(get_model, self).__init__()</span><br><span class="line">        in_channel = <span class="number">6</span> <span class="keyword">if</span> normal_channel <span class="keyword">else</span> <span class="number">3</span></span><br><span class="line">        self.normal_channel = normal_channel</span><br><span class="line">        self.sa1 = PointNetSetAbstraction(npoint=<span class="number">512</span>, radius=<span class="number">0.2</span>, K=<span class="number">32</span>, in_channel=in_channel, mlp=[<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], group_all=<span class="literal">False</span>)</span><br><span class="line">        self.sa2 = PointNetSetAbstraction(npoint=<span class="number">128</span>, radius=<span class="number">0.4</span>, K=<span class="number">64</span>, in_channel=<span class="number">128</span> + <span class="number">3</span>, mlp=[<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>], group_all=<span class="literal">False</span>)</span><br><span class="line">        self.sa3 = PointNetSetAbstraction(npoint=<span class="literal">None</span>, radius=<span class="literal">None</span>, K=<span class="literal">None</span>, in_channel=<span class="number">256</span> + <span class="number">3</span>, mlp=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>], group_all=<span class="literal">True</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm1d(<span class="number">512</span>)</span><br><span class="line">        self.drop1 = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm1d(<span class="number">256</span>)</span><br><span class="line">        self.drop2 = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">256</span>, num_class)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz</span>):</span>	<span class="comment">#xyz = [B, 3+ C(0 or 3), N_0]</span></span><br><span class="line">        B, _, _ = xyz.shape</span><br><span class="line">        <span class="keyword">if</span> self.normal_channel:</span><br><span class="line">            norm = xyz[:, <span class="number">3</span>:, :]	<span class="comment"># norm = [B, 0 or 3, N_0] (如果用到了法向量)</span></span><br><span class="line">            xyz = xyz[:, :<span class="number">3</span>, :]		<span class="comment"># xyz = [B, 3, N_0]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            norm = <span class="literal">None</span></span><br><span class="line">        l1_xyz, l1_features = self.sa1(xyz, norm)	</span><br><span class="line">        <span class="comment"># l1_xyz = [B, 3, 512], l1_features = [B, 128, 512]</span></span><br><span class="line">        l2_xyz, l2_features = self.sa2(l1_xyz, l1_features)</span><br><span class="line">        <span class="comment"># l2_xyz = [B, 3, 128], l1_features = [B, 256, 128]</span></span><br><span class="line">        l3_xyz, l3_features = self.sa3(l2_xyz, l2_features)</span><br><span class="line">        <span class="comment"># l3_xyz = [B, 1, 3], l3_features = [B, 1, 1024]</span></span><br><span class="line">        <span class="comment"># 如果只是利用PointNet++提取特征的话，这样就可以了</span></span><br><span class="line">        x = l3_features.view(B, <span class="number">1024</span>)</span><br><span class="line">        x = self.drop1(F.relu(self.bn1(self.fc1(x))))	<span class="comment"># [B, 1024] -&gt; [B, 512]</span></span><br><span class="line">        x = self.drop2(F.relu(self.bn2(self.fc2(x))))	<span class="comment"># [B, 512] -&gt; [B, 256]</span></span><br><span class="line">        x = self.fc3(x)									<span class="comment"># [B, 256] -&gt; [B, 40]</span></span><br><span class="line">        x = F.log_softmax(x, -<span class="number">1</span>)	</span><br><span class="line">        <span class="keyword">return</span> x, l3_features</span><br></pre></td></tr></table></figure>

<p>​    接下来其实就是看set abstraction模块了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNetSetAbstraction</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, npoint, radius, K, in_channel, mlp, group_all</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PointNetSetAbstraction, self).__init__()</span><br><span class="line">        self.npoint = npoint</span><br><span class="line">        self.radius = radius</span><br><span class="line">        self.K = K</span><br><span class="line">        self.mlp_convs = nn.ModuleList()</span><br><span class="line">        self.mlp_bns = nn.ModuleList()</span><br><span class="line">        last_channel = in_channel</span><br><span class="line">        <span class="keyword">for</span> out_channel <span class="keyword">in</span> mlp:</span><br><span class="line">            self.mlp_convs.append(nn.Conv2d(last_channel, out_channel, <span class="number">1</span>))	<span class="comment"># 卷积核大小为1</span></span><br><span class="line">            self.mlp_bns.append(nn.BatchNorm2d(out_channel))</span><br><span class="line">            last_channel = out_channel</span><br><span class="line">        <span class="comment"># 对于sa1来说，就是有 3个MLP层，每层的卷积核大小都是1*1</span></span><br><span class="line">        <span class="comment"># 第一层 [B, 3+C_i, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 第二层 [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 第三层 [B, 64, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, 128, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            </span><br><span class="line">        self.group_all = group_all</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Input:</span></span><br><span class="line"><span class="string">            xyz: input points position data, [B, 3, N_i]</span></span><br><span class="line"><span class="string">            features: input points feature data, [B, C_i, N_i]</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            new_xyz: sampled points position data, [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">            new_features: sample points feature data, [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xyz = xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> features <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            features = features.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.group_all:</span><br><span class="line">            new_xyz, new_features = sample_and_group_all(xyz, features)</span><br><span class="line">            <span class="comment"># new_xyz = [B, 1, 3]</span></span><br><span class="line">            <span class="comment"># new_features = [B, 1, K_&#123;i+1&#125;, 3+C_i]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_xyz, new_features = sample_and_group(self.npoint, self.radius, self.K, xyz, features)</span><br><span class="line">        <span class="comment"># new_xyz: sampled points position data, [B, N_&#123;i+1&#125;, 3]</span></span><br><span class="line">        <span class="comment"># new_features: sampled points position and feature data, [B, N_&#123;i+1&#125;, K_&#123;i+1&#125;, 3+C_i]</span></span><br><span class="line">        new_features_concat = new_points.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># [B, 3+C_i, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.mlp_convs):</span><br><span class="line">            bn = self.mlp_bns[i]</span><br><span class="line">            new_features_concat = F.relu(bn(conv(new_features_concat)))</span><br><span class="line">        <span class="comment"># [B, C_&#123;i+1&#125;, K_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">		</span><br><span class="line">        new_features_concat = torch.<span class="built_in">max</span>(new_features_concat, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># [B, C_&#123;i+1&#125;, K_&#123;i+1&#125;, N_&#123;i+1&#125;] -&gt; [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="comment"># 其实就是说从邻域特征中找到一个最大响应的值，因为每次处理的邻域的半径不同，所以每次提取特征响应的感受野也不同，实现了不同尺度下的特征提取</span></span><br><span class="line">        new_xyz = new_xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># [B, N_&#123;i+1&#125;, 3] -&gt; [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_features_concat	</span><br></pre></td></tr></table></figure>

<p>​    对于set abstraction layer来说，它的输入是$B\times N_{i} \times (3+C_i)$，而它的输出是$B\times N_{i+1}\times(3+C_{i+1})$。</p>
<p>​    理论上这样我们的分类任务已经可以完成了，这也是SSG(single-scale grouping)的情况。我们需要再看一下论文所提出的MSG的set abstraction module是如何实现的。</p>
<p>​    我们可以看到models里总体架构没有变，唯一有区别的就是两个sa层变为了SA_MSG。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.sa1 = PointNetSetAbstractionMsg(npoint=<span class="number">512</span>, radius_list=[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>], K_list=[<span class="number">16</span>, <span class="number">32</span>, <span class="number">128</span>], in_channel=in_channel, mlp_list=[[<span class="number">32</span>, <span class="number">32</span>, <span class="number">64</span>], [<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], [<span class="number">64</span>, <span class="number">96</span>, <span class="number">128</span>]])</span><br><span class="line">self.sa2 = PointNetSetAbstractionMsg(npoint=<span class="number">128</span>, radius_list=[<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>], K_list=[<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>], in_channel=<span class="number">320</span>, mlp_list=[[<span class="number">64</span>, <span class="number">64</span>, <span class="number">128</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>]])</span><br><span class="line">self.sa3 = PointNetSetAbstraction(npoint=<span class="literal">None</span>, radius=<span class="literal">None</span>, K=<span class="literal">None</span>, in_channel=<span class="number">640</span> + <span class="number">3</span>, mlp=[<span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>], group_all=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>​    其实我们只要搞明白上述的in_channel各自是怎么来的。以sa2的in_channel为例：<br>$$<br>\text{in_channel}=320=\Sigma_j(\text{out_channel}_j)=64+128+128<br>$$<br>​    这样我们就明白了，其实就是把不同的radius所提取的不同尺度的特征拼接在一起得到320维的特征向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointNetSetAbstractionMsg</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, npoint, radius_list, K_list, in_channel, mlp_list</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(PointNetSetAbstractionMsg, self).__init__()</span><br><span class="line">        self.npoint = npoint</span><br><span class="line">        self.radius_list = radius_list</span><br><span class="line">        self.nsample_list = nsample_list</span><br><span class="line">        self.conv_blocks = nn.ModuleList()</span><br><span class="line">        self.bn_blocks = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mlp_list)):</span><br><span class="line">            convs = nn.ModuleList()</span><br><span class="line">            bns = nn.ModuleList()</span><br><span class="line">            last_channel = in_channel + <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> out_channel <span class="keyword">in</span> mlp_list[i]:</span><br><span class="line">                convs.append(nn.Conv2d(last_channel, out_channel, <span class="number">1</span>))</span><br><span class="line">                bns.append(nn.BatchNorm2d(out_channel))</span><br><span class="line">                last_channel = out_channel</span><br><span class="line">            self.conv_blocks.append(convs)</span><br><span class="line">            self.bn_blocks.append(bns)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Input:</span></span><br><span class="line"><span class="string">            xyz: input points position data, [B, 3, N_i]</span></span><br><span class="line"><span class="string">            points: input points data, [B, C_i, N_i]</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            new_xyz: sampled points position data, [B, 3, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">            new_points_concat: sample points feature data, [B, C_&#123;i+1&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xyz = xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)   <span class="comment"># [B, N_i, 3]</span></span><br><span class="line">        <span class="keyword">if</span> points <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            points = points.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)    <span class="comment"># [B, N, C_i] ,C_i就是每个点额外的特征向量</span></span><br><span class="line"></span><br><span class="line">        B, N, C = xyz.shape</span><br><span class="line">        new_xyz = index_points(xyz, farthest_point_sample(xyz, self.npoint))  <span class="comment"># [B, N_&#123;i+1&#125;, C_i]</span></span><br><span class="line">        new_points_list = []</span><br><span class="line">        <span class="keyword">for</span> j, radius <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.radius_list):   <span class="comment"># 在不同的尺度下找ball query，枚举radius_list</span></span><br><span class="line">            K = self.nsample_list[j]    				<span class="comment"># 当前半径下，中心节点的邻居的数量</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ======================以下开始其实是sample_and_group的逻辑====================</span></span><br><span class="line">            group_idx = query_ball_point(radius, K, xyz, new_xyz)   </span><br><span class="line">            grouped_xyz = index_points(xyz, group_idx)  <span class="comment"># [B, 3, npoints, nsample]</span></span><br><span class="line">            grouped_xyz -= new_xyz.view(B, S, <span class="number">1</span>, C) <span class="comment"># ??? 转换成相对坐标</span></span><br><span class="line">            <span class="keyword">if</span> points <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                grouped_points = index_points(points, group_idx)</span><br><span class="line">                grouped_points = torch.cat([grouped_points, grouped_xyz], dim=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                grouped_points = grouped_xyz</span><br><span class="line">            <span class="comment"># ===========================================================================</span></span><br><span class="line"></span><br><span class="line">            grouped_points = grouped_points.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)  </span><br><span class="line">            <span class="comment"># [B, N_&#123;i+1&#125;, K_&#123;j&#125;, (3+D)] -&gt; [B, (3+D), K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.conv_blocks[j])):   </span><br><span class="line">                <span class="comment"># 所以mlp_list是一个二维数组，每一行都代表在对应半径下使用的input_channels</span></span><br><span class="line">                conv = self.conv_blocks[j][k]</span><br><span class="line">                bn = self.bn_blocks[j][k]</span><br><span class="line">                grouped_points = F.relu(bn(conv(grouped_points))) </span><br><span class="line">                <span class="comment"># 得到了 [B, out_channel_j, K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            <span class="comment"># 最终我们得到一个group_points, [B, out_channel_j, K_&#123;j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">            new_points = torch.<span class="built_in">max</span>(grouped_points, <span class="number">2</span>)[<span class="number">0</span>]  <span class="comment"># [B, out_channel_j, N_&#123;i+1&#125;]</span></span><br><span class="line">            new_points_list.append(new_points)</span><br><span class="line">        <span class="comment"># 最终new_points_list为 len_radius_list 个 [B, out_channel_j, N_&#123;i+1&#125;]</span></span><br><span class="line"></span><br><span class="line">        new_xyz = new_xyz.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        new_points_concat = torch.cat(new_points_list, dim=<span class="number">1</span>)   <span class="comment"># 最终得到 [B, sigma&#123;out_channel_j&#125;, N_&#123;i+1&#125;]</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;new_points_concat.size = &quot;</span>, new_points_concat)</span><br><span class="line">        <span class="keyword">return</span> new_xyz, new_points_concat</span><br></pre></td></tr></table></figure>



<p>Q：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266324173">PointNet++梯度是如何回传的？？？</a></p>
<p>A：PointNet++ fps实际上并没有参与梯度计算和反向传播。</p>
<p>可以理解成是PointNet++将点云进行不同规模的fps降采样，事先将这些数据准备好，再送到网络中去训练。</p>
<h1 id="VoteNet"><a href="#VoteNet" class="headerlink" title="VoteNet"></a>VoteNet</h1><p>​    VoteNet是基于end-to-end的3D目标检测网络，它基于3D的深度点云网络和霍夫投票。</p>
<p>​    可以从<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fq4y127k3">讲解视频</a>和<a target="_blank" rel="noopener" href="https://www.kami-code.com/2022/01/17/machine-learning-pre/">PPT</a>获得相关内容。</p>
<p><img src="/blog/blog/2021/12/22/pointnet-and-related-works/image-20220209002255184.png"></p>
<h2 id="votenet-py"><a href="#votenet-py" class="headerlink" title="votenet.py"></a>votenet.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoteNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        A deep neural network for 3D object detection with end-to-end optimizable hough voting.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        num_class: int</span></span><br><span class="line"><span class="string">            Number of semantics classes to predict over -- size of softmax classifier</span></span><br><span class="line"><span class="string">        num_heading_bin: int</span></span><br><span class="line"><span class="string">        num_size_cluster: int</span></span><br><span class="line"><span class="string">        input_feature_dim: (default: 0)</span></span><br><span class="line"><span class="string">            Input dim in the feature descriptor for each point.  If the point cloud is Nx9, this</span></span><br><span class="line"><span class="string">            value should be 6 as in an Nx9 point cloud, 3 of the channels are xyz, and 6 are feature descriptors</span></span><br><span class="line"><span class="string">        num_proposal: int (default: 128)</span></span><br><span class="line"><span class="string">            Number of proposals/detections generated from the network. Each proposal is a 3D OBB with a semantic class.</span></span><br><span class="line"><span class="string">        vote_factor: (default: 1)</span></span><br><span class="line"><span class="string">            Number of votes generated from each seed point.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_class, num_heading_bin, num_size_cluster, mean_size_arr,</span></span></span><br><span class="line"><span class="params"><span class="function">        input_feature_dim=<span class="number">0</span>, num_proposal=<span class="number">128</span>, vote_factor=<span class="number">1</span>, sampling=<span class="string">&#x27;vote_fps&#x27;</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        ...</span><br><span class="line">		<span class="comment"># omit variable init</span></span><br><span class="line">		...</span><br><span class="line">        <span class="comment"># Backbone point feature learning</span></span><br><span class="line">        self.backbone_net = Pointnet2Backbone(input_feature_dim=self.input_feature_dim)</span><br><span class="line">        <span class="comment"># Hough voting</span></span><br><span class="line">        self.vgen = VotingModule(self.vote_factor, <span class="number">256</span>)</span><br><span class="line">        <span class="comment"># Vote aggregation and detection</span></span><br><span class="line">        self.pnet = ProposalModule(num_class, num_heading_bin, num_size_cluster,</span><br><span class="line">            mean_size_arr, num_proposal, sampling)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Forward pass of the network</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            inputs: dict</span></span><br><span class="line"><span class="string">                &#123;point_clouds&#125;</span></span><br><span class="line"><span class="string">                point_clouds: Variable(torch.cuda.FloatTensor)</span></span><br><span class="line"><span class="string">                    (B, N, 3 + input_channels) tensor</span></span><br><span class="line"><span class="string">                    Point cloud to run predicts on</span></span><br><span class="line"><span class="string">                    Each point in the point-cloud MUST</span></span><br><span class="line"><span class="string">                    be formated as (x, y, z, features...)</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            end_points: dict</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        end_points = &#123;&#125;</span><br><span class="line">        batch_size = inputs[<span class="string">&#x27;point_clouds&#x27;</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        end_points = self.backbone_net(inputs[<span class="string">&#x27;point_clouds&#x27;</span>], end_points)</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># --------- HOUGH VOTING ---------</span></span><br><span class="line">        xyz = end_points[<span class="string">&#x27;fp2_xyz&#x27;</span>]					<span class="comment"># (B, M, 3)</span></span><br><span class="line">        features = end_points[<span class="string">&#x27;fp2_features&#x27;</span>]		<span class="comment"># (B, M, 256)</span></span><br><span class="line">        end_points[<span class="string">&#x27;seed_inds&#x27;</span>] = end_points[<span class="string">&#x27;fp2_inds&#x27;</span>]</span><br><span class="line">        end_points[<span class="string">&#x27;seed_xyz&#x27;</span>] = xyz						<span class="comment"># (batch_size, num_seed, 3)</span></span><br><span class="line">        end_points[<span class="string">&#x27;seed_features&#x27;</span>] = features				<span class="comment"># (batch_size, num_seed, 256)</span></span><br><span class="line">        </span><br><span class="line">        xyz, features = self.vgen(xyz, features)</span><br><span class="line">        <span class="comment"># xyz 		: (batch_size, num_vote, 3)</span></span><br><span class="line">        <span class="comment"># features 	: (batch_size, out_dim, num_vote)</span></span><br><span class="line">        features_norm = torch.norm(features, p=<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># features_norm 	: (batch_size, num_vote)</span></span><br><span class="line">        features = features.div(features_norm.unsqueeze(<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># features 	: (batch_size, out_dim, num_vote)，此时features已经归一化了特征</span></span><br><span class="line">        end_points[<span class="string">&#x27;vote_xyz&#x27;</span>] = xyz</span><br><span class="line">        end_points[<span class="string">&#x27;vote_features&#x27;</span>] = features</span><br><span class="line"></span><br><span class="line">        end_points = self.pnet(xyz, features, end_points)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> end_points</span><br></pre></td></tr></table></figure>



<h2 id="voting-module-py"><a href="#voting-module-py" class="headerlink" title="voting_module.py"></a>voting_module.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VotingModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vote_factor, seed_feature_dim</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Votes generation from seed point features.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            vote_facotr: int</span></span><br><span class="line"><span class="string">                number of votes generated from each seed point</span></span><br><span class="line"><span class="string">            seed_feature_dim: int</span></span><br><span class="line"><span class="string">                number of channels of seed point features</span></span><br><span class="line"><span class="string">            vote_feature_dim: int</span></span><br><span class="line"><span class="string">                number of channels of vote features</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.vote_factor = vote_factor</span><br><span class="line">        self.in_dim = seed_feature_dim</span><br><span class="line">        self.out_dim = self.in_dim <span class="comment"># due to residual feature, in_dim has to be == out_dim</span></span><br><span class="line">        self.conv1 = torch.nn.Conv1d(self.in_dim, self.in_dim, <span class="number">1</span>)</span><br><span class="line">        self.conv2 = torch.nn.Conv1d(self.in_dim, self.in_dim, <span class="number">1</span>)</span><br><span class="line">        self.conv3 = torch.nn.Conv1d(self.in_dim, (<span class="number">3</span>+self.out_dim) * self.vote_factor, <span class="number">1</span>)</span><br><span class="line">        self.bn1 = torch.nn.BatchNorm1d(self.in_dim)</span><br><span class="line">        self.bn2 = torch.nn.BatchNorm1d(self.in_dim)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, seed_xyz, seed_features</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Forward pass.</span></span><br><span class="line"><span class="string">        Arguments:</span></span><br><span class="line"><span class="string">            seed_xyz: 		(batch_size, num_seed, 3)</span></span><br><span class="line"><span class="string">            seed_features: 	(batch_size, feature_dim, num_seed)</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            vote_xyz: 		(batch_size, num_seed*vote_factor, 3)</span></span><br><span class="line"><span class="string">            vote_features: 	(batch_size, vote_feature_dim, num_seed*vote_factor)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        batch_size = seed_xyz.shape[<span class="number">0</span>]</span><br><span class="line">        num_seed = seed_xyz.shape[<span class="number">1</span>]</span><br><span class="line">        num_vote = num_seed * self.vote_factor</span><br><span class="line">        net = F.relu(self.bn1(self.conv1(seed_features))) </span><br><span class="line">        net = F.relu(self.bn2(self.conv2(net))) </span><br><span class="line">        net = self.conv3(net) </span><br><span class="line">        <span class="comment"># (batch_size, feature_dim, num_seed) =&gt; (batch_size, (3+out_dim)*vote_factor, num_seed)</span></span><br><span class="line">                </span><br><span class="line">        net = net.transpose(<span class="number">2</span>,<span class="number">1</span>).view(batch_size, num_seed, self.vote_factor, <span class="number">3</span>+self.out_dim)</span><br><span class="line">        <span class="comment"># (batch_size, num_seed, vote_factor, 3+self.out_dim)</span></span><br><span class="line">        <span class="comment"># 对于每个seed，生成vote_factor个vote，每个vote的特征维度为3+self.out_dim（3+256）</span></span><br><span class="line">        offset = net[:,:,:,<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        <span class="comment"># (batch_size, num_seed, vote_factor, 3)</span></span><br><span class="line">        vote_xyz = seed_xyz.unsqueeze(<span class="number">2</span>) + offset</span><br><span class="line">        <span class="comment"># (batch_size, num_seed, 1, 3) =&gt; (batch_size, num_seed, vote_factor, 3)</span></span><br><span class="line">        vote_xyz = vote_xyz.contiguous().view(batch_size, num_vote, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># (batch_size, num_vote, 3)</span></span><br><span class="line">        </span><br><span class="line">        residual_features = net[:,:,:,<span class="number">3</span>:] </span><br><span class="line">        <span class="comment"># seed_features: 	(batch_size, feature_dim, num_seed)</span></span><br><span class="line">        vote_features = seed_features.transpose(<span class="number">2</span>,<span class="number">1</span>).unsqueeze(<span class="number">2</span>) + residual_features</span><br><span class="line">        <span class="comment"># (batch_size, num_seed, feature_dim) =&gt; # (batch_size, num_seed, vote_factor, out_dim)</span></span><br><span class="line">        vote_features = vote_features.contiguous().view(batch_size, num_vote, self.out_dim)</span><br><span class="line">        vote_features = vote_features.transpose(<span class="number">2</span>,<span class="number">1</span>).contiguous()</span><br><span class="line">        <span class="comment"># (batch_size, out_dim, num_vote)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vote_xyz, vote_features</span><br></pre></td></tr></table></figure>



<h2 id="proposal-module-py"><a href="#proposal-module-py" class="headerlink" title="proposal_module.py"></a>proposal_module.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProposalModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_class, num_heading_bin, num_size_cluster, mean_size_arr, num_proposal, sampling, seed_feat_dim=<span class="number">256</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__() </span><br><span class="line">        ...</span><br><span class="line">		<span class="comment"># omit variable init</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Vote clustering</span></span><br><span class="line">        self.vote_aggregation = PointnetSAModuleVotes( </span><br><span class="line">                npoint=self.num_proposal,</span><br><span class="line">                radius=<span class="number">0.3</span>,</span><br><span class="line">                nsample=<span class="number">16</span>,</span><br><span class="line">                mlp=[self.seed_feat_dim, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>],</span><br><span class="line">                use_xyz=<span class="literal">True</span>,</span><br><span class="line">                normalize_xyz=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Object proposal/detection</span></span><br><span class="line">        <span class="comment"># Objectness scores (2), center residual (3),</span></span><br><span class="line">        <span class="comment"># heading class+residual (num_heading_bin*2), size class+residual(num_size_cluster*4)</span></span><br><span class="line">        self.conv1 = torch.nn.Conv1d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">1</span>)</span><br><span class="line">        self.conv2 = torch.nn.Conv1d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">1</span>)</span><br><span class="line">        self.conv3 = torch.nn.Conv1d(<span class="number">128</span>,<span class="number">2</span> + <span class="number">3</span> + num_heading_bin * <span class="number">2</span> + num_size_cluster * <span class="number">4</span> + self.num_class,<span class="number">1</span>)</span><br><span class="line">        self.bn1 = torch.nn.BatchNorm1d(<span class="number">128</span>)</span><br><span class="line">        self.bn2 = torch.nn.BatchNorm1d(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, xyz, features, end_points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            xyz: 		(batch_size, num_vote, 3)</span></span><br><span class="line"><span class="string">            features: 	(batch_size, out_dim, num_vote)</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            scores: 	(batch_size, num_proposal, 2 + 3 + NH * 2 + NS * 4) </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.sampling == <span class="string">&#x27;vote_fps&#x27;</span>:</span><br><span class="line">            <span class="comment"># Farthest point sampling (FPS) on votes</span></span><br><span class="line">            xyz, features, fps_inds = self.vote_aggregation(xyz, features)</span><br><span class="line">            sample_inds = fps_inds</span><br><span class="line">        <span class="keyword">elif</span> self.sampling == <span class="string">&#x27;seed_fps&#x27;</span>: </span><br><span class="line">            <span class="comment"># FPS on seed and choose the votes corresponding to the seeds</span></span><br><span class="line">            <span class="comment"># This gets us a slightly better coverage of *object* votes than vote_fps (which tends to get more cluster votes)</span></span><br><span class="line">            sample_inds = pointnet2_utils.furthest_point_sample(end_points[<span class="string">&#x27;seed_xyz&#x27;</span>], self.num_proposal)</span><br><span class="line">            xyz, features, _ = self.vote_aggregation(xyz, features, sample_inds)</span><br><span class="line">        <span class="keyword">elif</span> self.sampling == <span class="string">&#x27;random&#x27;</span>:</span><br><span class="line">            <span class="comment"># Random sampling from the votes</span></span><br><span class="line">            num_seed = end_points[<span class="string">&#x27;seed_xyz&#x27;</span>].shape[<span class="number">1</span>]</span><br><span class="line">            batch_size = end_points[<span class="string">&#x27;seed_xyz&#x27;</span>].shape[<span class="number">0</span>]</span><br><span class="line">            sample_inds = torch.randint(<span class="number">0</span>, num_seed, (batch_size, self.num_proposal), dtype=torch.<span class="built_in">int</span>).cuda()</span><br><span class="line">            <span class="comment"># (batch_size, num_proposal)</span></span><br><span class="line">            xyz, features, _ = self.vote_aggregation(xyz, features, sample_inds)</span><br><span class="line">		<span class="comment"># xyz : 		(batch_size, num_proposal, 3)</span></span><br><span class="line">        <span class="comment"># features : 	(batch_size, 128, num_proposal)</span></span><br><span class="line">        end_points[<span class="string">&#x27;aggregated_vote_xyz&#x27;</span>] = xyz <span class="comment"># (batch_size, num_proposal, 3)</span></span><br><span class="line">        end_points[<span class="string">&#x27;aggregated_vote_inds&#x27;</span>] = sample_inds <span class="comment"># (batch_size, num_proposal,) # should be 0,1,2,...,num_proposal</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --------- PROPOSAL GENERATION ---------</span></span><br><span class="line">        net = F.relu(self.bn1(self.conv1(features))) </span><br><span class="line">        net = F.relu(self.bn2(self.conv2(net))) </span><br><span class="line">        net = self.conv3(net)</span><br><span class="line">        <span class="comment"># (batch_size, 2 + 3 + num_heading_bin * 2 + num_size_cluster * 4, num_proposal)</span></span><br><span class="line"></span><br><span class="line">        end_points = decode_scores(net, end_points, self.num_class, self.num_heading_bin, self.num_size_cluster, self.mean_size_arr)</span><br><span class="line">        <span class="keyword">return</span> end_points</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_scores</span>(<span class="params">net, end_points, num_class, num_heading_bin, num_size_cluster, mean_size_arr</span>):</span></span><br><span class="line">    net_transposed = net.transpose(<span class="number">2</span>,<span class="number">1</span>) </span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, 2 + 3 + num_heading_bin * 2 + num_size_cluster * 4)</span></span><br><span class="line">    batch_size = net_transposed.shape[<span class="number">0</span>]</span><br><span class="line">    num_proposal = net_transposed.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    objectness_scores = net_transposed[:,:,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    end_points[<span class="string">&#x27;objectness_scores&#x27;</span>] = objectness_scores</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, 2)</span></span><br><span class="line">    </span><br><span class="line">    base_xyz = end_points[<span class="string">&#x27;aggregated_vote_xyz&#x27;</span>] 	<span class="comment"># (batch_size, num_proposal, 3)</span></span><br><span class="line">    center = base_xyz + net_transposed[:, :, <span class="number">2</span>:<span class="number">5</span>] 	<span class="comment"># (batch_size, num_proposal, 3)</span></span><br><span class="line">    end_points[<span class="string">&#x27;center&#x27;</span>] = center</span><br><span class="line"></span><br><span class="line">    heading_scores = net_transposed[:, :, <span class="number">5</span>:<span class="number">5</span> + num_heading_bin]</span><br><span class="line">    end_points[<span class="string">&#x27;heading_scores&#x27;</span>] = heading_scores</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, num_heading_bin)</span></span><br><span class="line">    </span><br><span class="line">    heading_residuals_normalized = net_transposed[:, :, <span class="number">5</span> + num_heading_bin:<span class="number">5</span> + num_heading_bin * <span class="number">2</span>]</span><br><span class="line">    end_points[<span class="string">&#x27;heading_residuals_normalized&#x27;</span>] = heading_residuals_normalized</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, num_heading_bin) (should be -1 to 1)</span></span><br><span class="line">    </span><br><span class="line">    end_points[<span class="string">&#x27;heading_residuals&#x27;</span>] = heading_residuals_normalized * (np.pi / num_heading_bin)</span><br><span class="line">    <span class="comment"># 因为residual的每个值在-1到1</span></span><br><span class="line">    <span class="comment"># 所以这样做完以后heading_residuals的值就在[-np.pi / num_heading_bin, np.pi / num_heading_bin]</span></span><br><span class="line"></span><br><span class="line">    size_scores = net_transposed[:, :, <span class="number">5</span> + num_heading_bin * <span class="number">2</span>:<span class="number">5</span> + num_heading_bin * <span class="number">2</span> + num_size_cluster]</span><br><span class="line">    end_points[<span class="string">&#x27;size_scores&#x27;</span>] = size_scores</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, num_size_cluster)</span></span><br><span class="line">    </span><br><span class="line">    size_residuals_normalized = net_transposed[:, :, <span class="number">5</span> + num_heading_bin * <span class="number">2</span> + num_size_cluster:<span class="number">5</span> + num_heading_bin * <span class="number">2</span> + num_size_cluster * <span class="number">4</span>].view([batch_size, num_proposal, num_size_cluster, <span class="number">3</span>]) </span><br><span class="line">    end_points[<span class="string">&#x27;size_residuals_normalized&#x27;</span>] = size_residuals_normalized</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, num_size_cluster * 3)</span></span><br><span class="line">    </span><br><span class="line">    end_points[<span class="string">&#x27;size_residuals&#x27;</span>] = size_residuals_normalized * torch.from_numpy(mean_size_arr.astype(np.float32)).cuda().unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    sem_cls_scores = net_transposed[:,:,<span class="number">5</span> + num_heading_bin * <span class="number">2</span> + num_size_cluster * <span class="number">4</span>:] </span><br><span class="line">    end_points[<span class="string">&#x27;sem_cls_scores&#x27;</span>] = sem_cls_scores</span><br><span class="line">    <span class="comment"># (batch_size, num_proposal, 10)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> end_points</span><br></pre></td></tr></table></figure>

<p>​    在默认情况下，我们decode_scores对256个检测框每个输出12个heading分类和12个heading的res，10个size分类和10个size的res，3个中心点的坐标，2个代表有无目标，以及10类分类的置信度。</p>
<h2 id="loss-helper-py"><a href="#loss-helper-py" class="headerlink" title="loss_helper.py"></a>loss_helper.py</h2><p>​    VoteNet的总的Loss由vote_loss, objectness_loss, box loss, sem cls loss组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_loss</span>(<span class="params">end_points, config</span>):</span></span><br><span class="line">    <span class="comment"># Loss functions</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Vote loss</span></span><br><span class="line">    vote_loss = compute_vote_loss(end_points)</span><br><span class="line">    end_points[<span class="string">&#x27;vote_loss&#x27;</span>] = vote_loss</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Obj loss</span></span><br><span class="line">    objectness_loss, objectness_label, objectness_mask, object_assignment =   compute_objectness_loss(end_points)</span><br><span class="line">    end_points[<span class="string">&#x27;objectness_loss&#x27;</span>] = objectness_loss</span><br><span class="line">    end_points[<span class="string">&#x27;objectness_label&#x27;</span>] = objectness_label</span><br><span class="line">    end_points[<span class="string">&#x27;objectness_mask&#x27;</span>] = objectness_mask</span><br><span class="line">    end_points[<span class="string">&#x27;object_assignment&#x27;</span>] = object_assignment</span><br><span class="line">    total_num_proposal = objectness_label.shape[<span class="number">0</span>]*objectness_label.shape[<span class="number">1</span>]</span><br><span class="line">    end_points[<span class="string">&#x27;pos_ratio&#x27;</span>] = torch.<span class="built_in">sum</span>(objectness_label.<span class="built_in">float</span>().cuda())/<span class="built_in">float</span>(total_num_proposal)</span><br><span class="line">    end_points[<span class="string">&#x27;neg_ratio&#x27;</span>] = torch.<span class="built_in">sum</span>(objectness_mask.<span class="built_in">float</span>())/<span class="built_in">float</span>(total_num_proposal) - end_points[<span class="string">&#x27;pos_ratio&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Box loss and sem cls loss</span></span><br><span class="line">    center_loss, heading_cls_loss, heading_reg_loss, size_cls_loss, size_reg_loss, sem_cls_loss = \</span><br><span class="line">        compute_box_and_sem_cls_loss(end_points, config)</span><br><span class="line">    end_points[<span class="string">&#x27;center_loss&#x27;</span>] = center_loss</span><br><span class="line">    end_points[<span class="string">&#x27;heading_cls_loss&#x27;</span>] = heading_cls_loss</span><br><span class="line">    end_points[<span class="string">&#x27;heading_reg_loss&#x27;</span>] = heading_reg_loss</span><br><span class="line">    end_points[<span class="string">&#x27;size_cls_loss&#x27;</span>] = size_cls_loss</span><br><span class="line">    end_points[<span class="string">&#x27;size_reg_loss&#x27;</span>] = size_reg_loss</span><br><span class="line">    end_points[<span class="string">&#x27;sem_cls_loss&#x27;</span>] = sem_cls_loss</span><br><span class="line">    box_loss = center_loss + <span class="number">0.1</span>*heading_cls_loss + heading_reg_loss + <span class="number">0.1</span>*size_cls_loss + size_reg_loss</span><br><span class="line">    end_points[<span class="string">&#x27;box_loss&#x27;</span>] = box_loss</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Final loss function</span></span><br><span class="line">    loss = vote_loss + <span class="number">0.5</span>*objectness_loss + box_loss + <span class="number">0.1</span>*sem_cls_loss</span><br><span class="line">    loss *= <span class="number">10</span></span><br><span class="line">    end_points[<span class="string">&#x27;loss&#x27;</span>] = loss</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------------------------------------</span></span><br><span class="line">    <span class="comment"># Some other statistics</span></span><br><span class="line">    obj_pred_val = torch.argmax(end_points[<span class="string">&#x27;objectness_scores&#x27;</span>], <span class="number">2</span>) <span class="comment"># B,K</span></span><br><span class="line">    obj_acc = torch.<span class="built_in">sum</span>((obj_pred_val==objectness_label.long()).<span class="built_in">float</span>()*objectness_mask)/(torch.<span class="built_in">sum</span>(objectness_mask)+<span class="number">1e-6</span>)</span><br><span class="line">    end_points[<span class="string">&#x27;obj_acc&#x27;</span>] = obj_acc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss, end_points</span><br></pre></td></tr></table></figure>

<h3 id="vote-loss"><a href="#vote-loss" class="headerlink" title="vote loss"></a>vote loss</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_vote_loss</span>(<span class="params">end_points</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute vote loss: Match predicted votes to GT votes.          </span></span><br><span class="line"><span class="string">    Overall idea:</span></span><br><span class="line"><span class="string">    	如果我们的seed point属于一个物体（votes_label_mask == 1），那么我们需要它向着物体中心投票</span></span><br><span class="line"><span class="string">    	每个seed point可能投票出多个translation v1,v2,v3</span></span><br><span class="line"><span class="string">    	一个seed point也可能在多个物体o1,o2,o3的bounding box中，对应的GT vote为 c1, c2, c3</span></span><br><span class="line"><span class="string">    	对于这个seed point的loss为： min(d(v_i,c_j)) for i=1,2,3 and j=1,2,3</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load ground truth votes and assign them to seed points</span></span><br><span class="line">    batch_size = end_points[<span class="string">&#x27;seed_xyz&#x27;</span>].shape[<span class="number">0</span>]</span><br><span class="line">    num_seed = end_points[<span class="string">&#x27;seed_xyz&#x27;</span>].shape[<span class="number">1</span>] 		<span class="comment"># (B, num_seed, 3)</span></span><br><span class="line">    vote_xyz = end_points[<span class="string">&#x27;vote_xyz&#x27;</span>] 				<span class="comment"># (B, num_seed * vote_factor, 3)</span></span><br><span class="line">    seed_inds = end_points[<span class="string">&#x27;seed_inds&#x27;</span>].long() 		<span class="comment"># (B, num_seed) in [0,num_points-1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get groundtruth votes for the seed points</span></span><br><span class="line">    <span class="comment"># vote_label_mask: Use gather to select B,num_seed from B,num_point</span></span><br><span class="line">    <span class="comment">#   non-object point has no GT vote mask = 0, object point has mask = 1</span></span><br><span class="line">    <span class="comment"># vote_label: Use gather to select B,num_seed,9 from B,num_point,9</span></span><br><span class="line">    <span class="comment">#   with inds in shape B,num_seed,9 and 9 = GT_VOTE_FACTOR * 3</span></span><br><span class="line">    seed_gt_votes_mask = torch.gather(end_points[<span class="string">&#x27;vote_label_mask&#x27;</span>], <span class="number">1</span>, seed_inds)</span><br><span class="line">    seed_inds_expand = seed_inds.view(batch_size,num_seed,<span class="number">1</span>).repeat(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span> * GT_VOTE_FACTOR)</span><br><span class="line">    seed_gt_votes = torch.gather(end_points[<span class="string">&#x27;vote_label&#x27;</span>], <span class="number">1</span>, seed_inds_expand)</span><br><span class="line">    seed_gt_votes += end_points[<span class="string">&#x27;seed_xyz&#x27;</span>].repeat(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute the min of min of distance</span></span><br><span class="line">    vote_xyz_reshape = vote_xyz.view(batch_size*num_seed, -<span class="number">1</span>, <span class="number">3</span>) </span><br><span class="line">    <span class="comment"># (B, num_seed * vote_factor, 3) =&gt; (B * num_seed, vote_factor, 3)</span></span><br><span class="line">    seed_gt_votes_reshape = seed_gt_votes.view(batch_size*num_seed, GT_VOTE_FACTOR, <span class="number">3</span>) </span><br><span class="line">    <span class="comment"># (B, num_seed, 3 * GT_VOTE_FACTOR) =&gt; (B * num_seed, GT_VOTE_FACTOR, 3)</span></span><br><span class="line">    <span class="comment"># A predicted vote to no where is not penalized as long as there is a good vote near the GT vote.</span></span><br><span class="line">    dist1, _, dist2, _ = nn_distance(vote_xyz_reshape, seed_gt_votes_reshape, l1=<span class="literal">True</span>)</span><br><span class="line">    votes_dist, _ = torch.<span class="built_in">min</span>(dist2, dim=<span class="number">1</span>) </span><br><span class="line">    votes_dist = votes_dist.view(batch_size, num_seed)</span><br><span class="line">    <span class="comment"># (B * num_seed, vote_factor) =&gt; (B * num_seed,) =&gt; (B, num_seed)</span></span><br><span class="line">    vote_loss = torch.<span class="built_in">sum</span>(votes_dist * seed_gt_votes_mask.<span class="built_in">float</span>()) / (torch.<span class="built_in">sum</span>(seed_gt_votes_mask.<span class="built_in">float</span>()) + <span class="number">1e-6</span>)</span><br><span class="line">    <span class="keyword">return</span> vote_loss</span><br></pre></td></tr></table></figure>

<h3 id="objectness-loss"><a href="#objectness-loss" class="headerlink" title="objectness loss"></a>objectness loss</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_objectness_loss</span>(<span class="params">end_points</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute objectness loss for the proposals.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        end_points: dict (read-only)</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        objectness_loss: scalar Tensor</span></span><br><span class="line"><span class="string">        objectness_label: (batch_size, num_seed) Tensor with value 0 or 1</span></span><br><span class="line"><span class="string">        objectness_mask: (batch_size, num_seed) Tensor with value 0 or 1</span></span><br><span class="line"><span class="string">        object_assignment: (batch_size, num_seed) Tensor with long int</span></span><br><span class="line"><span class="string">            within [0,num_gt_object-1]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="comment"># Associate proposal and GT objects by point-to-point distances</span></span><br><span class="line">    aggregated_vote_xyz = end_points[<span class="string">&#x27;aggregated_vote_xyz&#x27;</span>]</span><br><span class="line">    gt_center = end_points[<span class="string">&#x27;center_label&#x27;</span>][:,:,<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    B = gt_center.shape[<span class="number">0</span>]</span><br><span class="line">    K = aggregated_vote_xyz.shape[<span class="number">1</span>]</span><br><span class="line">    K2 = gt_center.shape[<span class="number">1</span>]</span><br><span class="line">    dist1, ind1, dist2, _ = nn_distance(aggregated_vote_xyz, gt_center) <span class="comment"># dist1: BxK, dist2: BxK2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate objectness label and mask</span></span><br><span class="line">    <span class="comment"># objectness_label: 1 if pred object center is within NEAR_THRESHOLD of any GT object</span></span><br><span class="line">    <span class="comment"># objectness_mask: 0 if pred object center is in gray zone (DONOTCARE), 1 otherwise</span></span><br><span class="line">    euclidean_dist1 = torch.sqrt(dist1+<span class="number">1e-6</span>)</span><br><span class="line">    objectness_label = torch.zeros((B,K), dtype=torch.long).cuda()</span><br><span class="line">    objectness_mask = torch.zeros((B,K)).cuda()</span><br><span class="line">    objectness_label[euclidean_dist1&lt;NEAR_THRESHOLD] = <span class="number">1</span></span><br><span class="line">    objectness_mask[euclidean_dist1&lt;NEAR_THRESHOLD] = <span class="number">1</span></span><br><span class="line">    objectness_mask[euclidean_dist1&gt;FAR_THRESHOLD] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute objectness loss</span></span><br><span class="line">    objectness_scores = end_points[<span class="string">&#x27;objectness_scores&#x27;</span>]</span><br><span class="line">    criterion = nn.CrossEntropyLoss(torch.Tensor(OBJECTNESS_CLS_WEIGHTS).cuda(), reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    objectness_loss = criterion(objectness_scores.transpose(<span class="number">2</span>,<span class="number">1</span>), objectness_label)</span><br><span class="line">    objectness_loss = torch.<span class="built_in">sum</span>(objectness_loss * objectness_mask)/(torch.<span class="built_in">sum</span>(objectness_mask)+<span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set assignment</span></span><br><span class="line">    object_assignment = ind1 <span class="comment"># (B,K) with values in 0,1,...,K2-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objectness_loss, objectness_label, objectness_mask, object_assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="box-and-sem-cls-loss"><a href="#box-and-sem-cls-loss" class="headerlink" title="box and sem cls loss"></a>box and sem cls loss</h3><p>论文中的描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The max-pooled features are further processed by MLP2 with output sizes of 128, 128, 5+2NH+4NS+NC where the output consists of 2 objectness scores, 3 center regression values, 2NH numbers for heading regression (NH heading bins) and 4NS numbers for box size regression (NS box anchors) and NC numbers for semantic classification</span><br></pre></td></tr></table></figure>

<p>​    其实，根据VoteNet引用的Frustum PointNet所提到的，两篇文章都只考虑了Up-axis轴上的角度作为heading angle，对于3D Bounding Box做了2个自由度的简化。那么其实就很容易懂了，把180度分成12份，先预测在哪个bin中，再回归bin内的偏移量是多少。而size bin以及size residual是类似的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_box_and_sem_cls_loss</span>(<span class="params">end_points, config</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute 3D bounding box and semantic classification loss.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        end_points: dict (read-only)</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        center_loss</span></span><br><span class="line"><span class="string">        heading_cls_loss</span></span><br><span class="line"><span class="string">        heading_reg_loss</span></span><br><span class="line"><span class="string">        size_cls_loss</span></span><br><span class="line"><span class="string">        size_reg_loss</span></span><br><span class="line"><span class="string">        sem_cls_loss</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    num_heading_bin = config.num_heading_bin</span><br><span class="line">    num_size_cluster = config.num_size_cluster</span><br><span class="line">    num_class = config.num_class</span><br><span class="line">    mean_size_arr = config.mean_size_arr</span><br><span class="line"></span><br><span class="line">    object_assignment = end_points[<span class="string">&#x27;object_assignment&#x27;</span>]</span><br><span class="line">    batch_size = object_assignment.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute center loss</span></span><br><span class="line">    <span class="comment"># 因为是K个点，K2个物体，我们把Loss分成两部分</span></span><br><span class="line">    <span class="comment"># centroid_reg_loss1 (B, K)： 距离每个点最近的GT物体的距离</span></span><br><span class="line">    <span class="comment"># centroid_reg_loss2 (B, K1)： 距离每个GT物体最近的center的距离</span></span><br><span class="line">    <span class="comment"># 这样的话就把对应关系考虑进去了</span></span><br><span class="line">    pred_center = end_points[<span class="string">&#x27;center&#x27;</span>]</span><br><span class="line">    gt_center = end_points[<span class="string">&#x27;center_label&#x27;</span>][:, :, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    dist1, ind1, dist2, _ = nn_distance(pred_center, gt_center) <span class="comment"># dist1: BxK, dist2: BxK2</span></span><br><span class="line">    box_label_mask = end_points[<span class="string">&#x27;box_label_mask&#x27;</span>]</span><br><span class="line">    objectness_label = end_points[<span class="string">&#x27;objectness_label&#x27;</span>].<span class="built_in">float</span>()</span><br><span class="line">    centroid_reg_loss1 = torch.<span class="built_in">sum</span>(dist1 * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label) + <span class="number">1e-6</span>)</span><br><span class="line">    centroid_reg_loss2 = torch.<span class="built_in">sum</span>(dist2 * box_label_mask) / (torch.<span class="built_in">sum</span>(box_label_mask) + <span class="number">1e-6</span>)</span><br><span class="line">    center_loss = centroid_reg_loss1 + centroid_reg_loss2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute heading loss</span></span><br><span class="line">    heading_class_label = torch.gather(end_points[<span class="string">&#x27;heading_class_label&#x27;</span>], <span class="number">1</span>, object_assignment)</span><br><span class="line">    <span class="comment"># select (B,K) from (B,K2)，得到每个点的GT heading class</span></span><br><span class="line">    <span class="comment"># end_points[&#x27;heading_scores&#x27;].transpose(2,1): (batch_size, num_heading_bin, K)</span></span><br><span class="line">    criterion_heading_class = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    heading_class_loss = criterion_heading_class(end_points[<span class="string">&#x27;heading_scores&#x27;</span>].transpose(<span class="number">2</span>,<span class="number">1</span>), heading_class_label) </span><br><span class="line">    <span class="comment"># (B,K)</span></span><br><span class="line">    heading_class_loss = torch.<span class="built_in">sum</span>(heading_class_loss * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label) + <span class="number">1e-6</span>)</span><br><span class="line">    <span class="comment"># 这里就是对heading bin做了多分类，并且在Loss和的时候只考虑了objectness_label == 1的情况，并且归一化</span></span><br><span class="line"></span><br><span class="line">    heading_residual_label = torch.gather(end_points[<span class="string">&#x27;heading_residual_label&#x27;</span>], <span class="number">1</span>, object_assignment) </span><br><span class="line">    <span class="comment"># select (B,K) from (B,K2)</span></span><br><span class="line">    heading_residual_normalized_label = heading_residual_label / (np.pi/num_heading_bin)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ref: https://discuss.pytorch.org/t/convert-int-into-one-hot-format/507/3</span></span><br><span class="line">    heading_label_one_hot = torch.cuda.FloatTensor(batch_size, heading_class_label.shape[<span class="number">1</span>], num_heading_bin).zero_()</span><br><span class="line">    heading_label_one_hot.scatter_(<span class="number">2</span>, heading_class_label.unsqueeze(-<span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># src==1 so it&#x27;s *one-hot* (B,K,num_heading_bin)</span></span><br><span class="line">    heading_residual_normalized_loss = huber_loss(torch.<span class="built_in">sum</span>(end_points[<span class="string">&#x27;heading_residuals_normalized&#x27;</span>] * heading_label_one_hot, -<span class="number">1</span>) - heading_residual_normalized_label, delta=<span class="number">1.0</span>) <span class="comment"># (B,K)</span></span><br><span class="line">    heading_residual_normalized_loss = torch.<span class="built_in">sum</span>(heading_residual_normalized_loss * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label)+<span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute size loss</span></span><br><span class="line">    size_class_label = torch.gather(end_points[<span class="string">&#x27;size_class_label&#x27;</span>], <span class="number">1</span>, object_assignment)</span><br><span class="line">    <span class="comment"># select (B,K) from (B,K2)</span></span><br><span class="line">    criterion_size_class = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    size_class_loss = criterion_size_class(end_points[<span class="string">&#x27;size_scores&#x27;</span>].transpose(<span class="number">2</span>,<span class="number">1</span>), size_class_label) <span class="comment"># (B,K)</span></span><br><span class="line">    size_class_loss = torch.<span class="built_in">sum</span>(size_class_loss * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label) + <span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line">    size_residual_label = torch.gather(end_points[<span class="string">&#x27;size_residual_label&#x27;</span>], <span class="number">1</span>, object_assignment.unsqueeze(-<span class="number">1</span>).repeat(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)) </span><br><span class="line">    <span class="comment"># select (B,K,3) from (B,K2,3)</span></span><br><span class="line">    size_label_one_hot = torch.cuda.FloatTensor(batch_size, size_class_label.shape[<span class="number">1</span>], num_size_cluster).zero_()</span><br><span class="line">    size_label_one_hot.scatter_(<span class="number">2</span>, size_class_label.unsqueeze(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># src==1 so it&#x27;s *one-hot* (B,K,num_size_cluster)</span></span><br><span class="line">    size_label_one_hot_tiled = size_label_one_hot.unsqueeze(-<span class="number">1</span>).repeat(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>) <span class="comment"># (B,K,num_size_cluster,3)</span></span><br><span class="line">    predicted_size_residual_normalized = torch.<span class="built_in">sum</span>(end_points[<span class="string">&#x27;size_residuals_normalized&#x27;</span>]*size_label_one_hot_tiled, <span class="number">2</span>) <span class="comment"># (B,K,3)</span></span><br><span class="line"></span><br><span class="line">    mean_size_arr_expanded = torch.from_numpy(mean_size_arr.astype(np.float32)).cuda().unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>) </span><br><span class="line">    <span class="comment"># (1,1,num_size_cluster,3) </span></span><br><span class="line">    mean_size_label = torch.<span class="built_in">sum</span>(size_label_one_hot_tiled * mean_size_arr_expanded, <span class="number">2</span>) <span class="comment"># (B,K,3)</span></span><br><span class="line">    size_residual_label_normalized = size_residual_label / mean_size_label <span class="comment"># (B,K,3)</span></span><br><span class="line">    size_residual_normalized_loss = torch.mean(huber_loss(predicted_size_residual_normalized - size_residual_label_normalized, delta=<span class="number">1.0</span>), -<span class="number">1</span>) <span class="comment"># (B,K,3) -&gt; (B,K)</span></span><br><span class="line">    size_residual_normalized_loss = torch.<span class="built_in">sum</span>(size_residual_normalized_loss * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label) + <span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute Semantic cls loss，此处就是算预测的多分类交叉熵</span></span><br><span class="line">    sem_cls_label = torch.gather(end_points[<span class="string">&#x27;sem_cls_label&#x27;</span>], <span class="number">1</span>, object_assignment) </span><br><span class="line">    <span class="comment"># select (B,K) from (B,K2)</span></span><br><span class="line">    criterion_sem_cls = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    sem_cls_loss = criterion_sem_cls(end_points[<span class="string">&#x27;sem_cls_scores&#x27;</span>].transpose(<span class="number">2</span>,<span class="number">1</span>), sem_cls_label) <span class="comment"># (B,K)</span></span><br><span class="line">    sem_cls_loss = torch.<span class="built_in">sum</span>(sem_cls_loss * objectness_label) / (torch.<span class="built_in">sum</span>(objectness_label) + <span class="number">1e-6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> center_loss, heading_class_loss, heading_residual_normalized_loss, size_class_loss, size_residual_normalized_loss, sem_cls_loss</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>PointNet and related works</p><p><a href="https://kami-code.com/blog/2021/12/22/pointnet-and-related-works/">https://kami-code.com/blog/2021/12/22/pointnet-and-related-works/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Kami-code</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-12-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-02-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/blog/tags/VoteNet/">VoteNet</a><a class="link-muted mr-2" rel="tag" href="/blog/tags/PointNet/">PointNet</a><a class="link-muted mr-2" rel="tag" href="/blog/tags/PointNet/">PointNet++</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog/2022/01/17/machine-learning-pre/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">VoteNet presentation</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/2021/12/20/screwnet/"><span class="level-item">(ICRA2021)ScrewNet</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="SOHUCS" sid="2021/12/22/pointnet-and-related-works/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cyvI88c19',conf: 'prod_634561f1ec380218934dcf2c12b8b70b'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/blog/img/avatar.jpg" alt="Chen Bao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Chen Bao</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/blog/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/blog/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/blog/tags"><p class="title">38</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kami-code" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kami-code"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-22T06:43:39.000Z">2022-03-22</time></p><p class="title"><a href="/blog/2022/03/22/dual_boot/">双系统的配置和安装</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-13T08:18:21.000Z">2022-03-13</time></p><p class="title"><a href="/blog/2022/03/13/GraspTTA/">(ICCV2021)Hand-Object Contact Consistency Reasoning for Human Grasps Generation</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-02T06:24:03.000Z">2022-03-02</time></p><p class="title"><a href="/blog/2022/03/02/NOCS/">(CVPR2019)NOCS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-20T14:35:48.000Z">2022-02-20</time></p><p class="title"><a href="/blog/2022/02/20/A-SDF/">(ICCV2021)A-SDF</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-19T13:44:21.000Z">2022-02-19</time></p><p class="title"><a href="/blog/2022/02/19/akb48/">A Real-World Articulated Object Knowledge Base</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/blog/tags/Affordance/"><span class="tag">Affordance</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/BCO/"><span class="tag">BCO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/CHOMP/"><span class="tag">CHOMP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/CVPR/"><span class="tag">CVPR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Camera/"><span class="tag">Camera</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/GraspNet/"><span class="tag">GraspNet</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ICCV/"><span class="tag">ICCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ICRA/"><span class="tag">ICRA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/IJCAI/"><span class="tag">IJCAI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/IROS/"><span class="tag">IROS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Neo4j/"><span class="tag">Neo4j</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/OpenGL/"><span class="tag">OpenGL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/PointNet/"><span class="tag">PointNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/PointNet/"><span class="tag">PointNet++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Pybind11/"><span class="tag">Pybind11</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Pybullet/"><span class="tag">Pybullet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ROS/"><span class="tag">ROS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/RSS/"><span class="tag">RSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/SE3353/"><span class="tag">SE3353</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/SOIL/"><span class="tag">SOIL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ScrewNet/"><span class="tag">ScrewNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Search/"><span class="tag">Search</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/VoteNet/"><span class="tag">VoteNet</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/WebService/"><span class="tag">WebService</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/behavior-tree/"><span class="tag">behavior tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/compliers/"><span class="tag">compliers</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/deeplearning/"><span class="tag">deeplearning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ikfast/"><span class="tag">ikfast</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/lab/"><span class="tag">lab</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/mmdection/"><span class="tag">mmdection</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/moveit/"><span class="tag">moveit</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/planning/"><span class="tag">planning</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/pybullet/"><span class="tag">pybullet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/segmentation/"><span class="tag">segmentation</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/img/logo.svg" alt="Ryan &#039;s website" height="28"></a><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><p class="is-size-7"><span>&copy; 2023 Kami-code</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>