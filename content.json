{"pages":[],"posts":[{"title":"MoveIt Setup Assistant","text":"​ This article shows how to configure a custom arm in MoveIt. 1. Load the model​ Make sure that your moveit is correctly configured before moving on the turorial. And this article is mainly adapted from ROS MoveIt tutorial, but I configure a flexiv robot not a franka-panda. ​ First, use the following command to open the moveit setup assistant GUI. 1roslaunch moveit_setup_assistant setup_assistant.launch ​ Press “Create New MoveIt Configuration Package”, and choose the .urdf file. ​ After importing the urdf model, you can check the robot model in the right. If there something wrong, like missing part, or some red error shown in the bash, try to check the correctness of the urdf model. Those urdf models that are not following the ROS conventions can not be correctly processed by the MoveIt setup assistant. 2. Compute the self-collisions matrix​ Just press the button, if there are no special needs. 3. Define virtual joints​ Virtual joints are used primarily to attach the robot to the world. ​ For our flexiv model, we can find in urdf there is a joint0 serving as virtual joints in the urdf, ​ so we don’t add one more joint here, but if we fail at last, we may return back here to move the virtual joint in the urdf. 4. Define planning groups​ Planning groups are necessary for us to plan in MoveIt. Here we first define a planning group called arm, which use kdl_kinematics_plugin. ​ And we need to press “add joints” to configure the planning group. ​ Joint 0 to 7 are added into the planning group, because later the kinematic solver will need the 7 joints to calculate solutions. ​ Next, we should configure a planning group called “hand”, with no ik solvers and all links contained by the gripper. The following picture is the result when we successfully configure both. 5. Define robot poses​ We can add some useful configurations to use in future. 6. Define end effectors 7. Add passive joints​ The passive joints tab is meant to allow specification of any passive joints that might exist in a robot. These are joints that are unactuated on a robot (e.g. passive casters.) This tells the planners that they cannot (kinematically) plan for these joints because they can’t be directly controlled. The Panda does not have any passive joints so we will skip this step.[1] Not quiet sure, I leave empty here as well. 8. 3D perception​ Not used here. 9. Simulation with Gazebo​ Gazebo is not used here. 10. ROS control​ Clicking the “Auto add …”, then we have ​ We should edit both one. ​ Change the first to a joint position controller. 11. Add author information​ Do what it says. 12. Configuration Files​ Just generate the package. 13. Visualize the robot in RViz​ We can visualize the robot in RViz by the following command after building the newly created package. 1roslaunch panda_moveit_config demo.launch ​ Everything seems to be in the right place. You can refer to RViz tutorial for more details.","link":"/2021/11/05/MoveIt-Setup-Assistant/"},{"title":"CHOMP_and_related_works","text":"​ 最近深感自己知识储备的不足，面对一个问题可能前人已经解决了，但是却自己根本摸不着头绪。准备好好开始看paper来增加自己的知识库储备。实验室的师兄师姐们都非常厉害，分分钟可以丢给我很多paper去看，希望借此机会可以增加自己研究的insight。 CHOMP​ CHOMP是一篇如雷贯耳的文章。刚进领域的时候就经常看见CHOMP,STOMP等planner，非常如雷贯耳，最近项目可能要添加进一些planner的因素，所以要先从这篇09年ICRA的祖师爷开始看起，注意同一批人在13年再次对CHOMP工作做了细致的讲解、提供了和RRT*的对比实验，并且提供了扩展到含额外约束的轨迹规划问题上。 ​ 其实CHOMP的思路比较直观，它有一个目标函数$U(\\xi)=f_{prior}(\\xi)+\\lambda f_{obstacle}(\\xi)$，最终目标就是优化这个目标函数得到轨迹$\\xi$。即有：$$\\xi^* = \\mathop{\\arg\\min}_{\\xi}U(\\xi)$$​ 其中，轨迹$\\xi(t)$可以认为是一个[0,1]$\\rightarrow R^m$的函数，我们把时间归一化到0~1之间，也就是说$\\xi(0)=q_{init}$以及$\\xi(1)=q_{goal}$。所以$U(\\xi)$就可以简单地认为是一个关于轨迹$\\xi$的损失函数。当它取到最小的时候我们即得到了一个最优的colision-free的轨迹。 动力学损失函数​ CHOMP的目标函数主要考虑了动力学带来的cost以及碰撞所带来的cost。我们可以先看动力学所带来的cost。$f_{prior}(\\xi)=\\displaystyle\\frac{1}{2}\\int^1_0 \\vert|\\frac{d}{dt}\\xi(t)||^2 dt$，这一项是直接对轨迹的速度的平方做积分，也可以扩展到加速度和加加速度的情况，是用来鼓励轨迹更加顺滑的。 碰撞损失函数​ 第二个损失函数就是说CHOMP希望规划出一条collision-free的轨迹，所以必须要把场景中的所有障碍物全部考虑进去。我们考虑机械臂外表面上的点集$B\\subset R^3$, u是其上一点。在某个构型下，我们显然可以通过构型的前向动力学信息以及机械臂上的相对坐标计算出其在欧式空间中的瞬时绝对坐标，我们记为$x(\\xi(t),u)$，有了这个坐标以后，那我们需要得到这一点离障碍物的距离，我们希望尽可能提升这个距离。所以我们引入了SDF距离（有向距离场），这个在图像渲染中用到的比较多，其实就是这个点到一个物体表面的最短距离。有了这个距离度量函数，我们可以构造出大于0的损失函数来尽可能最大化这个距离度量。所以我们有碰撞损失函数：$$\\displaystyle f_{obstacle}=\\int_0^1\\int_B c_{obstacle}(x(\\xi(t), u))|\\frac{d}{dt}x(\\xi(t),u)|dudt$$ ​ 在上式中，其实对机械臂的表面积做积分这件事情是比较显然的，但是之前一直很难理解为什么要乘上这个速度函数$x’(\\xi(t),u)=v(\\xi,u)$。理解起来也不复杂，因为我们的轨迹的时间归一化到了0~1之间。所以如果不乘上这个速度因子的话，就有可能导致两条运动速度不同而位置相同的轨迹算出来的损失函数是相等的，但是我们希望让以较快速度通过的有更大的损失，可能是因为较大的速度更容易碰撞时产生实际的负面影响，所以加上了速度因子后，就把时间归一化带来的多解问题消除掉了，可以理解为是一个保序变换。 优化过程​ 论文使用迭代的方式来更新轨迹$\\xi_k$，使用一阶泰勒展开$U(\\xi)\\approx U(\\xi_k)+g_k^T(\\xi-\\xi_k)$，其中$g_k=\\nabla U(\\xi_k)$。$$\\xi_{k+1}=\\xi_k-\\frac{1}{\\lambda}M^{-1}g_k$$ 推广到含约束的优化过程​ 有些轨迹创建过程可能需要额外的约束，比如传递水杯的时候我们可能希望水不要洒出来。所以在2013年的文章中，作者对把原先的CHOMP泛化到比较普遍的约束问题上。首先作者假设所有约束都可以按照轨迹在希尔伯特空间上非线性的可微分向量函数来定义：$H:\\Xi\\rightarrow R^k$，其中的$H(\\xi)=0$就是所有满足要求的约束的轨迹。 ​ 所以其实就是在我们之前的迭代过程中，我们此时迭代改写为：$$\\xi_{k+1}=\\xi_k-\\frac{1}{\\lambda}M^{-1}g_k \\\\s.t. H[\\xi]=0$$​ 为了得到一个具体的更新规则，我们在$\\xi_i$处对函数H进行一阶泰勒展开，也就是$H(\\xi)\\approx H(\\xi_i)+\\frac{\\partial}{\\partial\\xi}H(\\xi_i)(\\xi-\\xi_i)=C(\\xi-\\xi_i)+b$其中C是约束函数的Jacobian，而$b=H(\\xi_i)$，我们可以把带约束的迭代问题转化为拉格朗日约束下的梯度下降问题，具体过程不再描述。最终我们得到的更新规则为：$$\\xi_{k+1}=\\xi_k-\\frac{1}{\\lambda}A^{-1}g_k+\\frac{1}{\\lambda}A^{-1}C^T(CA^{-1}C^T)^{-1}CA^{-1}g_{k}-A^{-1}C^T(CA^{-1}C^T)^{-1}b$$ ​ 其实就是说在带约束的更新规则下，它先以无约束的方式优化一步，然后把A投影到穿过$\\xi_t$的超平面上，并且这个超平面与我们的约束函数在$\\xi_i$处的一阶泰勒展开的近似超平面$C(\\xi-\\xi_i)+b=0$平行。最终，它消除掉了两个超平面之间的平移量，使得下一步迭代$\\xi_{i+1}$更加接近于约束函数$H(\\xi)=0$上。 ​ 所以其实我们如果能够形式化定义出这个$H(\\xi)$的具体形式，那么找到满足这个约束的轨迹也只是一个优化的过程。 [RSS2020] 在线抓取合成和优化的轨迹创建​ 摘要的大致意思就是说轨迹创建和Grasp预测通常是分别处理的，这篇文章希望提出一个整合两个planning问题的方法。这篇文章整合出了一个轨迹优化方法和在线抓点合成/选取的一个结合办法，也就是在线学习并且挑选出最终抓点的6D pose。并且证明了在复杂环境中是可以鲁棒并且高效地创建出motion plan的。 ​ 避障自然就是使用了CHOMP算法，不再过多叙述。和这篇文章主打的Grasp相关的概念：给定一个场景中的多个物体，定义了可行的目标物体抓取集合$G\\subseteq Q\\subseteq R^d$。这样我们的优化问题就变成了：$$\\xi^* = \\mathop{\\arg\\min}_{\\xi}f_{motion}(\\xi) \\\\s.t.\\xi(1)\\in G$$​ 其中的损失函数$f_{motion}$自然就是CHOMP中的$U(\\xi)$，即$f_{motion}(\\xi)=f_{obstacle}(\\xi)+\\lambda f_{prior}(\\xi)$。所以这一步其实就是CHOMP含约束优化的一个实例。约束函数定义为$H(\\xi_i)=\\xi_i-g=0$，我们可以使用CHOMP含约束的更新规则来进行更新。我们可以定义$f_g(\\xi_i)$是在第i次迭代时，使用g作为目标抓点的损失函数。稍微有一点点不同的地方在于在不同迭代中选择的抓点g可能是不一样的。 在线学习抓点选择​ 如果我们直接使用CHOMP求解带约束g的优化函数，那么我们并没有考虑到一些轨迹上的特性，比如这篇ISRR2011所提到的损失函数可能陷入局部最优的情况。 ​ 如上图所示，这个例子如果我们梯度下降的起点选择的不好就很容易会陷入局部最优的情况，这是从机器学习角度是很容易理解的事情。不过，我们可以通过额外要求满足轨迹的一些Attributes来限定梯度下降的区域（起点）就是在那个可以达到局部最优的位置。 ​ 如上图所示，如果我们规定，所有轨迹都要满足“都从冰箱上方过去”，我们就可以把轨迹的优化范围限定在如右图所示的，可以到达全局最优点的位置。形式化地来说，我们可以定义一个好的轨迹应当满足的特质：$\\tau:S\\to A(\\Xi,S)$，其中S是抽象的任务描述，而$\\Xi$是可以解决任务的轨迹的集合，$A(\\Xi,S)$就代表了轨迹的属性，比如在上例中就是从冰箱门上方运动过去。我们就可以隐式地描述出原先轨迹集合$\\Xi$的一个子集：$\\Xi_A\\subseteq \\Xi$，我们从这个好轨迹集合中选取第二阶段优化的初始值，这样就可以避免局部最优的情况。所以总体流程就为$S\\to A(\\Xi,S)\\to \\xi\\in\\Xi_A\\to\\xi^*$。 ​ 我们继续回到这篇文章，我们如果想优化$f_g(\\xi_i)$，我们希望能够最大化motion generation success。文章使用了把第i次迭代时的Goal Set描述为了概率分布$p_i$，那么这一步其实就是在迭代计算$p_{i+1}$的过程，那么第i+1次迭代的时候，我们选取的目标抓点就是$g_{i+1}=\\arg\\max(p_{i+1})$，文章使用的赌博机算法（Bandit Algorithm）不再过多叙述，是一个简单的RL算法。 在线抓取合成​ 这一部分主要应用了CASE2018所提出的ISF算法，也就是从初始的有限抓取集合G出发，通过优化的方式在线合成更多质量更高的抓取点。优化的目标函数为：$$f_{grasp}(g)=f_{isf}(g)+\\gamma f_{collision}(g)$$​ ISF主要就是最大化夹爪和物体的接触面积，这件事情是通过对夹爪上的采样表面点和法向量，并且优化接触点位置处的法向量和距离得到的，ISF算法因为本身也设计到很多理解和推导，暂时不在这里描述。 ​ 并且此处有：$f_{collision}(g)=f_{hand_obstacle}+\\beta f_{obstacle}(g)$，这里的$f_{obstacle}$就是在CHOMP中的碰撞损失，而$f_{hand_obstacle}$指的就是在抓取的过程中，我们不希望robot的手部和待抓取的物体会出现任何的碰撞。 ​ 最终这篇文章提出的算法如下，每次迭代的时候，先用带约束的CHOMP创建轨迹，然后迭代更新Goal Set的分布，然后选取其中成功率最大的一个grasp作为goal，然后使用C-Space ISF方法来优化这个选取的grasp，使其抓取的成功率更大。","link":"/2021/12/09/CHOMP-and-related-works/"},{"title":"SE3353_assignment4","text":"简单总结一下这次作业。基于Lucene的全文搜索功能和WebService的封装。 在你的项目中增加基于Solr或Lucene的针对书籍简介的全文搜索功能，用户可以在搜索界面输入搜索关键词，你可以通过全文搜索引擎找到书籍简介中包含该关键词的书籍列表。为了实现起来方便，你可以自己设计文本文件格式来存储书籍简介信息。例如，你可以将所有书籍的简介信息存储成为JSON对象，包含书的ID和简介文本，每行存储一本书的JSON对象。 请将上述全文搜索功能开发并部署为Web Service。 一、开发基于Lucene的全文搜索功能我们实现一个ApplicationRunner接口，这样它会在SpringBoot启动的时候自动执行一次，把数据库中的书籍及其间接建立索引。 为了测试这个功能，我们添加了一个用于测试的Controller。 我们分别输入“你”和“奥秘”作为关键词，我们可以清楚地看见确实返回了所有包含关键词的书籍。 二、把全文搜索功能整合到WebService中 如果说第一部分在十分钟内就可以基本上完成的话，这部分就非常冗长了。首先是WebService的选型，我首先选了Jax-ws作为后端webservice的实现。后面实现起来一切正常，但是当我想整合前端时出现了巨大的问题。简而言之就是，前端因为要组装text/xml作为SOAP协议的body，但是在firefox和Chrome中，这属于“非简单请求”，会自动先发送一个preflight。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）”预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 就是因为这个OPTION请求让Jax-ws用不了，发请求的时候SpringBoot会报出： com.sun.xml.internal.ws.server.http : 无法处理 HTTP 方法: OPTIONS 我们需要定义interceptor去拦截这个OPTIONS请求，并且返回一个200:OK，但是找了半天不知道这个接口在哪里。使用SpringBoot的HandlerInterceptor也拦不到这个OPTIONS请求，陷入僵局。 后来看到了这篇文章js调用webservice接口时后台无法处理OPTIONS请求的解决方法，只能弃用Jax-ws，启用cxf。 拦截器参考网上的抄了一份过来，简单而言就是如果拦截到的是preflight，那就设置对应的Header后返回200:OK。 具体的webservice倒显得很容易了，如下是Service层的代码，还有一个CXFConfig类。 我们可以在对应暴露出的url后添加?wsdl，来得到这个webservice对应的wsdl文件。 理论上前端应该是要parse这个wsdl文件然后生成对应的SOAP消息的，不过限于时间，和具体业务其实不需要这么大的灵活度，所以就没做，固定了前端的格式。 值得一提的是，前端的SOAP消息格式是使用了SOAPUI这个软件，传入wsdl文件后自动生成出来的，节省了我很多debug的时间。 剩下的无非就是前端的一些工作了，封装出对应的SOAP消息生成和解析器即可。 搜索“你”和“奥秘”，结果与之前我们在controller中测试的结果完全相同。任务结束。","link":"/2021/10/20/SE3353-assignment4/"},{"title":"SE3353-assignment8","text":"简单总结一下这次作业。基于MongoDB和Neo4j的存储功能。 ​ 1.将你认为合适的内容改造为在MongoDB中存储，例如书的产品评价或书评。你可以参照课程样例将数据分别存储在MySQL和MongoDB中，也可以将所有数据都存储在MongoDB中，如果采用后者，需要确保系统功能都能正常实现，包括书籍浏览、查询、下订单和管理库存等。​ 2.为你的每一本图书都添加一些标签，在Neo4J中将这些标签构建成一张图。在系统中增加一项搜索功能，如果用户按照标签搜索，你可以将Neo4J中存储的与用户选中的标签以及通过2重关系可以关联到的所有标签都选出，作为搜索的依据，在MySQL中搜索所有带有这些标签中任意一个或多个的图书，作为图书搜索结果呈现给用户。 ​ 最近有点眼高手低，有些技术以前用过就自以为可以不必记录下来了。要遏制住这股风气，因为我并不了解任何工具的底层、实现也全靠CSDN，哪怕为了第二次复现起来、第二次快速回忆起现在做的事情，也需要详尽地写下目前的操作。 PART1：MongoDB首先是安装并运行MongoDB，在安装目录下，先运行mongod.exe，再运行mongo.exe即可看到如下的命令行： 123456789101112131415161718192021222324---&gt; 2 + 24&gt; db.runoob.insert({x:10})WriteResult({ &quot;nInserted&quot; : 1 })&gt; db.runoob.find(){ &quot;_id&quot; : ObjectId(&quot;6190c5a1e7f64d1430e95cde&quot;), &quot;x&quot; : 10 }&gt; db.auth(&quot;root&quot;,&quot;123456&quot;)Error: Authentication failed.0&gt; use adminswitched to db admin&gt; db.createUser({user:&quot;root&quot;,pwd:&quot;1234&quot;,roles:[{&quot;role&quot;:&quot;readWrite&quot;,&quot;db&quot;:&quot;demo&quot;}]})Successfully added user: { &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ { &quot;role&quot; : &quot;readWrite&quot;, &quot;db&quot; : &quot;demo&quot; } ]}&gt; db.auth(&quot;root&quot;,&quot;1234&quot;)1 ​ 我们在书店的DAO层中添加如下代码： 123456789101112131415@Overridepublic Book addRemark(Long book_id, String remark) { Book book = findOne(book_id); Remark remarks = book.getRemark(); if (remarks == null) { remarks = new Remark(book.getId()); } else { remarkRepository.delete(book.getRemark()); } remarks.addRemark(remark); book.setRemark(remarks); save(book); return book;} ​ 因为MongoDB不支持相同id的document的覆盖操作，所以我们每次取出来就删除掉，然后再把新的评论加上后再save到collection中，唯一的问题可能就是在delete后save前如果server crash了，可能会导致这个书籍的评论消失。可以通过额外的数据备份机制来避免这个情况。 ​ 使用ROBO3T可以看到，确实我们每次添加一条评论，就自动添加到Collection对应book id的document下了。 PART2：Neo4j​ 按照Neo4j desktop很快，但是把它在SpringBoot中调通用了很大波折。我发现只要加入spring-boot-starter-data-neo4j这个依赖，启动后就会报如下的错。 12345678org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'reactiveNeo4jTemplate' defined in class path resource [org/springframework/boot/autoconfigure/data/neo4j/Neo4jReactiveDataAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.data.neo4j.core.ReactiveNeo4jTemplate] from ClassLoader ...Caused by: java.lang.ClassNotFoundException: reactor.util.context.ContextView at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_91] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_91] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_91] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_91] ... 26 common frames omitted ​ 依赖也没冲突，代码都没开始写，就出这个问题，真的卡了好几个小时。后来不抱希望地看到了这个issue，添加了依赖： 123456&lt;!-- https://mvnrepository.com/artifact/io.projectreactor.netty/reactor-netty --&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor.netty&lt;/groupId&gt; &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt; &lt;version&gt;1.0.13&lt;/version&gt;&lt;/dependency&gt; ​ 居然就能用了，真是百思不得其解。 可见成功初始化，创建了由书籍和标签构成的一张图。 我们如下extend Neo4jRepository 123456public interface BookNodeRepository extends Neo4jRepository&lt;BookNode, Long&gt; { BookNode findByName(String name); BookNode findByTagNodesName(String name); @Query(&quot;MATCH (p:BookNode) -[:contain]-&gt;(p1:TagNode)&lt;-[:contain]- (p2:BookNode) where p.name=~ $n return p2&quot;) List&lt;BookNode&gt; findByTwoRelationship(@Param(&quot;n&quot;) String n);} 和我们在Neo4j Desktop中查询到的完全一样 Customizing Query by @Query annotation","link":"/2021/11/22/SE3353-assignment8/"},{"title":"behavior_tree_pre","text":"A internal talk of MVIG lab","link":"/2021/10/20/behavior-tree-pre/"},{"title":"SE335_Compliers_lab2","text":"总而言之前前后后好几天时间都在搞这个lab，不过主要花的时间可能是大半天时间。为了留下点东西，姑且总结一下这个lab。 其实这个lab可以说是烦而不难，基本上搞清楚flex c++的执行流，就完全可以干掉这个lab。 上面是一些无关痛痒的指令，算是第一步就可以很轻易写出来的东西。 一、处理嵌套注解 嵌套注解的处理其实从原理上就和括号匹配一样，至少要维护一个整形作为匹配的进度（/加一、/减一，最终为0时匹配完毕）。但是这样实现就要区分出在匹配完毕时（非注解情况下）和匹配进行时（注解情况下）的不同执行流，需要更改全部代码。其实，仔细查看lab2的提示和flex c++的文档就可以发现它提供了start condition来处理不同情况下的处理，这是一个很好用的工具。如上图所示，一旦匹配到了开始符号/*，那么自动push一个COMMENT状态即可；一旦匹配到了结束符号，那么就从栈中pop一个状态。 二、字符串的处理这部分是我debug了最久的地方，因为经常会出现匹配上了，但是开始的位置和标准答案差一个的情况、或者字符串后的各种符号平移了几位的情况，这是因为多种原因造成的： \\1. 比如A=”5”的情况，在匹配第一个”的时候，如果没有adjust，最终的开始位置就会在等号处。 \\2. 匹配转义字符时，不能根据最终转义完成的字符串的长度来计算adjust，这样会导致adjust数量过少。 首先是匹配普通字符串的情况，lex代码如下： 由于adjust函数会自动根据matched的字符串的长度来做调整位置，所以我们自己添加了一个adjustByLen，里面添加了对转义字符的offset。接下来是对转义字符的支持，主要可以分为四类： \\1. ^A, ^B, …., ^Z，具体其含义我们不细究，反正查ASCII表可知其值为1~26。 \\2. \\xxx，其中x为0~9的数字，也就是直接指定ASCII码。 \\3. \\n, \\t, \\”等，直接转义为对应字符即可。 \\4. \\跟了一个换行符的情况，我们需要支付字符串跨行输入，这个下一节再说。 总体逻辑就是trim我们的matched string，把转义使用的\\x都修剪掉，换成真的对应的转义字符。注意，我们需要累积计算我们的offset，这样我们才能知道最终我们需要移动多少位。 接下来是例子52中出现的这种情况： 我们自然也需要给予支持，也就是+一个换行符，自动进入ignore状态，等到读到下一个\\后，才退出到正常的字符串处理状态。注意ignore了多少个字符也需要添加进offset中。","link":"/2021/10/17/complier-lab2/"},{"title":"complier-lab3","text":"​ This lab comes from SE3355 *Compilers* lab3, which requires me to use Bisonc++ to implement a parser for the Tiger language. ​ The blog is written after the completion of the lab, so some details may be forgotten. Our main target of this lab is to use a sequence of tokens which the lab2’s lexical scanner gives, to parse them and create a AST(Abstract Syntax Tree). The AST representation is necessary for us to do the semantic type checking in the next lab. What’s more, we need to convert AST to a intermediate language then, for our final processing when trying to get assembly language and binary executable file. ​ For convenience and succinctness, I will not again to explain the basic structure and class of the AST in the code. The code will be provided in my github repo when all labs are finished. ​ If you are not familiar with the workflow of the Bison C++, refer to the documentation for more details. Part 1 Some Simple ProductionsAccording to Appendix A of tiger book, we can easily write down the following productions. 1.1 basic productions of expression​ The basic primitive expression constructor is necessary, which forms the lower-level nodes(mainly leaf nodes) of the AST. 123456exp : INT {$$ = new absyn::IntExp(scanner_.GetTokPos(), $1);} | MINUS exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::MINUS_OP, new absyn::IntExp(scanner_.GetTokPos(), 0), $2);} | STRING {$$ = new absyn::StringExp(scanner_.GetTokPos(), $1);} | lvalue {$$ = new absyn::VarExp(scanner_.GetTokPos(), $1);} | NIL {$$ = new absyn::NilExp(scanner_.GetTokPos());}; 1.2 Operation productions of expression1234567891011121314exp : MINUS INT {$$ = new absyn::IntExp(scanner_.GetTokPos(), -1 * $2);} | exp PLUS exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::PLUS_OP, $1, $3);} | exp MINUS exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::MINUS_OP, $1, $3);} | exp TIMES exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::TIMES_OP, $1, $3);} | exp DIVIDE exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::DIVIDE_OP, $1, $3);} | exp AND exp {$$ = new absyn::IfExp(scanner_.GetTokPos(), $1, $3, new absyn::IntExp(scanner_.GetTokPos(), 0));} | exp OR exp {$$ = new absyn::IfExp(scanner_.GetTokPos(), $1, new absyn::IntExp(scanner_.GetTokPos(), 1), $3);} | exp EQ exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::EQ_OP, $1, $3);} | exp NEQ exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::NEQ_OP, $1, $3);} | exp LT exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::LT_OP, $1, $3);} | exp LE exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::LE_OP, $1, $3);} | exp GT exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::GT_OP, $1, $3);} | exp GE exp {$$ = new absyn::OpExp(scanner_.GetTokPos(), absyn::GE_OP, $1, $3);}; ​ We need to highlight the implementation of the AND and OR operation. Since we don’t have a AND_OP and OR_OP in the predefined declarations of the AST. We can use the following conversion: 123exp1 AND exp2&lt;=&gt;if exp1 then exp2 else 0 123exp1 OR exp2&lt;=&gt;if exp1 then 1 else exp2 ​ Since in tiger language, the if-expression will return either the then-body or the else-body according to the condition, we can implement the conversion without any worry. 1.3 General Declarations123456789101112exp : LET decs IN expseq END {$$ = new absyn::LetExp(scanner_.GetTokPos(), $2, $4);};decs : decs_nonempty {$$ = $1;} | {$$ = new absyn::DecList();} //may be empty here;decs_nonempty : decs_nonempty_s decs {$$ = $2; $$-&gt;Prepend($1);};decs_nonempty_s : vardec {$$ = $1;} | tydec {$$ = new absyn::TypeDec(scanner_.GetTokPos(), $1);} | fundec {$$ = new absyn::FunctionDec(scanner_.GetTokPos(), $1);}; ​ In let-in-end format, tiger language allow empty declarations in production. So decs can be devided into empty one and non-empty one. For those are not empty, it can be forwardly inferred to a list of decs_nonempty_s. We use a DecList class to realize such behavior. For example, 1234some declaration;some declaration;some declaration;some declaration; will finally form a class of absyn::DecList with four declarations in its member variable dec_list_ whose type is std::List&lt;dec *&gt;. 1.4 Variable declaration12vardec : VAR ID ASSIGN exp {$$ = new absyn::VarDec(scanner_.GetTokPos(), $2, nullptr, $4);} | VAR ID COLON ID ASSIGN exp {$$ = new absyn::VarDec(scanner_.GetTokPos(), $2, $4, $6);}; ​ Since now, we can handle codes like 12var a := 3;var b : string := &quot;foo&quot;; 1.5 Type declaration1234567891011121314151617tydec : tydec_one tydec {$$ = $2; $$-&gt;Prepend($1);} | tydec_one {$$ = new absyn::NameAndTyList($1);};tydec_one : TYPE ID EQ ty {$$ = new absyn::NameAndTy($2, $4); };ty : ID {$$ = new absyn::NameTy(scanner_.GetTokPos(), $1);} | LBRACE tyfields RBRACE {$$ = new absyn::RecordTy(scanner_.GetTokPos(), $2);} | ARRAY OF ID {$$ = new absyn::ArrayTy(scanner_.GetTokPos(), $3);};tyfields : tyfields_nonempty {$$ = $1;} | {$$ = new absyn::FieldList();} //may be empty here;tyfields_nonempty : tyfield {$$ = new absyn::FieldList($1);} | tyfield COMMA tyfields_nonempty {$$ = $3; $$-&gt;Prepend($1);};tyfield : ID COLON ID {$$ = new absyn::Field(scanner_.GetTokPos(), $1, $3);}; ​ As we can see, the tydec also contains a list of tydec_one, so we can apply the same strategy when we handle decs. There are three type declaration in tiger language. 123type a = int;type b = array of a;type c = {name:string, score:b}; ​ So we can easily recognize the first and third line of ty production, but the nested one seems more difficult. Since the typefields is also a non-fixed size list, so we also need to split it into the empty one and non-empty one. Each production will add one element to the typefields. 1.7 Function declaration​ The function declaration consists of two types. 12function id (tyfields) = expfunction id (tyfields) : type-id = exp ​ So we can easily get the following code. 12345fundec : fundec_one {$$ = new absyn::FunDecList($1);} | fundec_one fundec {$$ = $2; $$-&gt;Prepend($1);};fundec_one : FUNCTION ID LPAREN tyfields RPAREN EQ exp {$$ = new absyn::FunDec(scanner_.GetTokPos(), $2, $4, nullptr, $7);} | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp {$$ = new absyn::FunDec(scanner_.GetTokPos(), $2, $4, $7, $9);}; 1.8 Nested type assignment​ To initialize those type are declared in nest as follows, 1list{first=i, rest=readlist()} ​ we can also have 123456789exp : ID LBRACE rec RBRACE {$$ = new absyn::RecordExp(scanner_.GetTokPos(), $1, $3);}rec : rec_nonempty {$$ = $1;} | {$$ = new absyn::EFieldList();};rec_nonempty : rec_one {$$ = new absyn::EFieldList($1);} | rec_one COMMA rec_nonempty {$$ = $3; $$-&gt;Prepend($1);};rec_one : ID EQ exp {$$ = new absyn::EField($1, $3);}; 1.9 Other productions​ According to Appendix A, it’s easy to understand the following code. 1234567891011121314151617181920212223exp : LPAREN sequencing RPAREN {$$ = new absyn::SeqExp(scanner_.GetTokPos(), $2);} | LPAREN exp RPAREN {$$ = $2;} | LPAREN RPAREN {$$ = new absyn::VoidExp(scanner_.GetTokPos());} | LET IN END {$$ = new absyn::VoidExp(scanner_.GetTokPos());} | ID LPAREN actuals RPAREN {$$ = new absyn::CallExp(scanner_.GetTokPos(), $1, $3);} | lvalue ASSIGN exp {$$ = new absyn::AssignExp(scanner_.GetTokPos(), $1, $3);} | WHILE exp DO exp {$$ = new absyn::WhileExp(scanner_.GetTokPos(), $2, $4);} | FOR ID ASSIGN exp TO exp DO exp {$$ = new absyn::ForExp(scanner_.GetTokPos(), $2, $4, $6, $8);} | BREAK {$$ = new absyn::BreakExp(scanner_.GetTokPos());}; actuals : nonemptyactuals {$$ = $1;} | {$$ = new absyn::ExpList();};nonemptyactuals : exp {$$ = new absyn::ExpList($1);} | exp COMMA nonemptyactuals {$$ = $3; $$-&gt;Prepend($1);};sequencing : exp sequencing_exps {$$ = $2; $$-&gt;Prepend($1); };sequencing_exps: SEMICOLON exp sequencing_exps {$$ = $3; $$-&gt;Prepend($2);} | {$$ = new absyn::ExpList();};expseq : {$$ = new absyn::VoidExp(scanner_.GetTokPos());} | sequencing {$$ = new absyn::SeqExp(scanner_.GetTokPos(), $1);}; Part 2 Handle shift-reduce conflict2.1 If-then-else conflict​ I solve the conflict according to blog. 12345%nonassoc THEN%nonassoc ELSE...exp : IF exp THEN exp ELSE exp {$$ = new absyn::IfExp(scanner_.GetTokPos(), $2, $4, $6);} | IF exp THEN exp {$$ = new absyn::IfExp(scanner_.GetTokPos(), $2, $4, nullptr);} 2.2 ID[exp] conflict​ I have spent a lot time on debugging this conflict. To be specific, the problem can be illustrated in the following sheet. 12345ID [exp] ·, OF shiftID [exp] ·, $ reduceID [exp] ·, DOT shiftID [exp] ·, [ shiftID [exp] ·, ASSIGN shift ​ Let’s take an example, 12345var b := intArray [N] of 0a = c[10]c[10].first = 5d[10][5] = 2row[7] := 1 ​ I have tried a lot of method from blog1 and blog2, but it seems neither of both are useful. To enforce every production do reduce first, I configure “special_one” to achieve my goal. 123456789101112131415exp : special_one OF exp {$$ = new absyn::ArrayExp(scanner_.GetTokPos(), ((absyn::SimpleVar *)(((absyn::SubscriptVar *)($1))-&gt;var_))-&gt;sym_, ((absyn::SubscriptVar *)($1))-&gt;subscript_, $3);}lvalue : oneormore DOT ID {$$ = new absyn::FieldVar(scanner_.GetTokPos(), $1, $3);} | oneormore LBRACK exp RBRACK {$$ = new absyn::SubscriptVar(scanner_.GetTokPos(), $1, $3);} | oneormore {$$ = $1;} | special_one DOT ID {$$ = new absyn::FieldVar(scanner_.GetTokPos(), $1, $3);} | special_one LBRACK exp RBRACK {$$ = new absyn::SubscriptVar(scanner_.GetTokPos(), $1, $3);} | special_one {$$ = $1;};special_one : one LBRACK exp RBRACK{$$ = new absyn::SubscriptVar(scanner_.GetTokPos(), $1, $3);};oneormore : one DOT ID {$$ = new absyn::FieldVar(scanner_.GetTokPos(), $1, $3);} | one {$$ = $1;};one : ID {$$ = new absyn::SimpleVar(scanner_.GetTokPos(), $1);}; ​ I configured special_one equals “id[exp]”, enforcing every “id[exp]” to be reduced to special_one.","link":"/2021/11/04/complier-lab3/"},{"title":"complier-lab4","text":"This lab comes from SE3355 *Compilers* lab4, which requires me to implement a type-checking module when scanning the AST. The AST is created by bisonc++ script implemented in lab3. To make the following statement more clear, we can take a see of the structure of the AST node. The venv contains the symbols of variables and functions and the tenv contains the symbols of all types. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Var {public: int pos_; virtual ~Var() = default; virtual void Print(FILE *out, int d) const = 0; virtual type::Ty *SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const = 0;protected: explicit Var(int pos) : pos_(pos) {}};class Exp {public: int pos_; virtual ~Exp() = default; virtual void Print(FILE *out, int d) const = 0; virtual type::Ty *SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const = 0;protected: explicit Exp(int pos) : pos_(pos) {}};class Dec {public: int pos_; virtual ~Dec() = default; virtual void Print(FILE *out, int d) const = 0; virtual void SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const = 0;protected: explicit Dec(int pos) : pos_(pos) {}};class Ty {public: int pos_; virtual ~Ty() = default; virtual void Print(FILE *out, int d) const = 0; virtual type::Ty *SemAnalyze(env::TEnvPtr tenv, err::ErrorMsg *errormsg) const = 0;protected: explicit Ty(int pos) : pos_(pos) {}}; Part 1 Some Basic Type Checking1.1 some root and leavesWe want to get the type of every variable, expression and declaration, so we can easily do it from the root and leaves. 1234567891011121314151617181920212223void AbsynTree::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, err::ErrorMsg *errormsg) const { root_-&gt;SemAnalyze(venv, tenv, 0, errormsg);}type::Ty *VarExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { return var_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg);}type::Ty *NilExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { return type::NilTy::Instance();}type::Ty *IntExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { return type::IntTy::Instance();}type::Ty *StringExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { return type::StringTy::Instance();}type::Ty *VoidExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { return type::VoidTy::Instance();} 1.2 VariablesThe type-checking code of three variables is as follows. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566type::Ty *SimpleVar::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv,int labelcount, err::ErrorMsg *errormsg) const { env::EnvEntry *entry = venv-&gt;Look(sym_); if (entry &amp;&amp; (typeid(*entry) == typeid(env::VarEntry))) { env::VarEntry* varEntry = static_cast&lt;env::VarEntry *&gt;(entry); type::Ty *type = varEntry-&gt;ty_; bool readonly = varEntry-&gt;readonly_; return type; } else { errormsg-&gt;Error(pos_, &quot;undefined variable %s&quot;, sym_-&gt;Name().data()); } return type::IntTy::Instance();}type::Ty *FieldVar::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv,int labelcount, err::ErrorMsg *errormsg) const { // for field var first check var need to be a RecordTy, then check the sym_ is in the recordTY type type::Ty * variable_type = var_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); if (variable_type == nullptr) { errormsg-&gt;Error(pos_, &quot;variable not defined.&quot;); } else if (typeid(*(variable_type-&gt;ActualTy())) != typeid(type::RecordTy)) { errormsg-&gt;Error(pos_, &quot;not a record type&quot;); } else { type::RecordTy * real_type = ((type::RecordTy *) (variable_type)); int matched = 0; for (type::Field* field:real_type-&gt;fields_-&gt;GetList()) { if (field-&gt;name_-&gt;Name() == sym_-&gt;Name()) { matched = 1; } } if (matched == 1) { return real_type; } else { errormsg-&gt;Error(pos_, &quot;field nam doesn't exist&quot;); return real_type; } }}type::Ty *SubscriptVar::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv,int labelcount, err::ErrorMsg *errormsg) const { //check the type of var_ is an array or not //if so, check subscript_ is an int or not, and check the range. type::Ty *var_type = var_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); //var_type is array of the type that we want to return if (var_type == nullptr) { errormsg-&gt;Error(pos_, &quot;variable not defined.&quot;); } else if (typeid(*(var_type-&gt;ActualTy())) != typeid(type::ArrayTy)) { errormsg-&gt;Error(pos_, &quot;array type required&quot;); } else { type::Ty *subscript_type = subscript_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); if (typeid(*(subscript_type-&gt;ActualTy())) != typeid(type::IntTy)) { errormsg-&gt;Error(pos_, &quot;subscribe is not a int type.&quot;); } else { return ((type::ArrayTy *) var_type)-&gt;ty_; } } return nullptr;} 1.3 Call expressionThe type-checking code of call expression is as follows. 12345678910111213141516171819202122232425262728293031323334353637383940414243type::Ty *CallExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { env::FunEntry *funEntry = static_cast&lt;env::FunEntry *&gt;(venv-&gt;Look(func_)); if (funEntry == nullptr) { errormsg-&gt;Error(pos_, &quot;undefined function &quot; + func_-&gt;Name()); return type::NilTy::Instance(); } std::list&lt;Exp *&gt; args_list = args_-&gt;GetList(); if (funEntry-&gt;formals_ == nullptr) { auto args_it = args_-&gt;GetList().begin(); for (; args_it != args_-&gt;GetList().end(); args_it++) { Exp *current_exp = *args_it; current_exp-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); } } else { auto formal_it = funEntry-&gt;formals_-&gt;GetList().begin(); auto args_it = args_-&gt;GetList().begin(); for (; formal_it != funEntry-&gt;formals_-&gt;GetList().end() &amp;&amp; args_it != args_-&gt;GetList().end(); formal_it++, args_it++) { Exp *current_exp = *args_it; type::Ty *formal_type = *formal_it; if (typeid(*(current_exp-&gt;SemAnalyze(venv, tenv, labelcount, errormsg)-&gt;ActualTy())) != typeid(*formal_type)) { // type not match errormsg-&gt;Error(current_exp-&gt;pos_, &quot;para type mismatch&quot;); } } if (args_it != args_-&gt;GetList().end()) { // number does not match auto last_it = args_-&gt;GetList().end(); last_it--; errormsg-&gt;Error((*last_it)-&gt;pos_, &quot;too many params in function g&quot;); } else if (formal_it != funEntry-&gt;formals_-&gt;GetList().end()) { } } if (funEntry-&gt;result_ != nullptr) { return funEntry-&gt;result_; } else { return type::NilTy::Instance(); }} Part 2 Some Tricky Part2.1 the loop variable shouldn’t be assignedSince the loop variable in a for-loop can’t not be assigned because of the rule of the tiger language, when a for-loop declares a variable, the variable should be marked with “readonly = true”. In such way, when encountering a variable in assign exp, the module can check the variable is read-only or not. 1234567891011121314151617181920212223242526272829303132333435363738type::Ty *ForExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { venv-&gt;BeginScope(); type::Ty *lo_type = lo_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); venv-&gt;Enter(var_, new env::VarEntry(lo_type, true)); type::Ty *hi_type = hi_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); if (typeid(*(hi_type-&gt;ActualTy())) != typeid(type::IntTy)) { errormsg-&gt;Error(hi_-&gt;pos_, &quot;for exp's range type is not integer&quot;); } body_-&gt;SemAnalyze(venv, tenv, labelcount + 1, errormsg); venv-&gt;EndScope(); return type::NilTy::Instance();}type::Ty *AssignExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { type::Ty *var_type = var_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); type::Ty *exp_type = exp_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); if (typeid(*(exp_type-&gt;ActualTy())) == typeid(type::NilTy) &amp;&amp; typeid(*(var_type-&gt;ActualTy())) == typeid(type::RecordTy)) { return type::NilTy::Instance(); } else if (var_type &amp;&amp; typeid(*(var_type)-&gt;ActualTy()) == typeid(type::IntTy)) { absyn::SimpleVar *simpleVar = dynamic_cast&lt;SimpleVar *&gt;(var_); if (simpleVar != nullptr) { env::EnvEntry *envEntry = venv-&gt;Look(simpleVar-&gt;sym_); if (envEntry != nullptr) { bool readonly = envEntry-&gt;readonly_; if (readonly) { errormsg-&gt;Error(pos_, &quot;loop variable can't be assigned&quot;); } } } } else if (var_type &amp;&amp; exp_type &amp;&amp; typeid(*(var_type-&gt;ActualTy())) != typeid(*(exp_type-&gt;ActualTy()))) { errormsg-&gt;Error(pos_, &quot; unmatched assign exp&quot;); } return type::NilTy::Instance();} 2.2 The in-loop checking of break expression123456789101112131415161718192021type::Ty *ForExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { ... body_-&gt;SemAnalyze(venv, tenv, labelcount + 1, errormsg); ...}type::Ty *WhileExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv,int labelcount, err::ErrorMsg *errormsg) const { ... type::Ty *body_type = body_-&gt;SemAnalyze(venv, tenv, labelcount + 1, errormsg); ...}type::Ty *BreakExp::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount, err::ErrorMsg *errormsg) const { if (labelcount == 0) { errormsg-&gt;Error(pos_, &quot;break is not inside any loop&quot;); } return type::NilTy::Instance();} 2.3 handle the nested function declarationTiger supports the adjacent nested function, so we need to define all the function name first in order for all the function to find the reference function entry in the venv. 123456789101112131415161718192021222324252627282930void FunctionDec::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv,int labelcount, err::ErrorMsg *errormsg) const { absyn::FunDec *last_function = nullptr; for (absyn::FunDec *function:functions_-&gt;GetList()) { if (last_function &amp;&amp; function-&gt;name_-&gt;Name() == last_function-&gt;name_-&gt;Name()) { errormsg-&gt;Error(function-&gt;pos_, &quot;two functions have the same name&quot;); } venv-&gt;Enter(function-&gt;name_, new env::FunEntry(nullptr, nullptr)); last_function = function; } for (absyn::FunDec *function:functions_-&gt;GetList()) { type::Ty *result_ty = tenv-&gt;Look(function-&gt;result_); type::TyList *formals = function-&gt;params_-&gt;MakeFormalTyList(tenv, errormsg); venv-&gt;Set(function-&gt;name_, new env::FunEntry(formals, result_ty)); venv-&gt;BeginScope(); auto formal_it = formals-&gt;GetList().begin(); auto param_it = function-&gt;params_-&gt;GetList().begin(); for (; param_it != function-&gt;params_-&gt;GetList().end(); formal_it++, param_it++) { venv-&gt;Enter((*param_it)-&gt;name_, new env::VarEntry(*formal_it)); } type::Ty *ty = function-&gt;body_-&gt;SemAnalyze(venv, tenv, labelcount, errormsg); errormsg-&gt;Error(pos_, &quot;function body over&quot;); if (function-&gt;result_ == nullptr &amp;&amp; ty &amp;&amp; typeid(*(ty-&gt;ActualTy())) != typeid(type::NilTy)) { errormsg-&gt;Error(pos_, &quot;procedure returns value&quot;); } venv-&gt;EndScope(); }} 2.4 illegal cycle in nested type declaration12345678910111213// test.16.tig/* error: mutually recursive types thet do not pass through record or array */let type a=ctype b=atype c=dtype d=ain &quot;&quot;end The upper code is not allowed in tiger language, so we need to check if there is a cycle in type nested declaration. Each time we define a new type, we need to scan the defined type in the venv to make sure there is no cycle. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void TypeDec::SemAnalyze(env::VEnvPtr venv, env::TEnvPtr tenv, int labelcount,err::ErrorMsg *errormsg) const { for (NameAndTy* current: types_-&gt;GetList()) { // put all the name into the env first sym::Symbol *symbol = current-&gt;name_; for (NameAndTy* current_2: types_-&gt;GetList()) { if (current_2 == current) break; if (current_2-&gt;name_-&gt;Name() == current-&gt;name_-&gt;Name()) { errormsg-&gt;Error(pos_, &quot;two types have the same name&quot;); } } tenv-&gt;Enter(symbol, new type::NameTy(symbol, nullptr)); } for (NameAndTy* current: types_-&gt;GetList()) { sym::Symbol *symbol = current-&gt;name_; errormsg-&gt;Error(pos_, &quot;define symbol &quot; + symbol-&gt;Name()); absyn::Ty* type = current-&gt;ty_; absyn::NameTy *changed_type1 = dynamic_cast&lt;absyn::NameTy *&gt;(type); absyn::ArrayTy *changed_type2 = dynamic_cast&lt;absyn::ArrayTy *&gt;(type); absyn::RecordTy *changed_type3 = dynamic_cast&lt;absyn::RecordTy *&gt;(type); if (changed_type1 != nullptr) { type::Ty *type1 = changed_type1-&gt;SemAnalyze(tenv, errormsg); tenv-&gt;Set(symbol, type1); try { type::Ty * test_type = tenv-&gt;Look(symbol); type::NameTy * change_one = dynamic_cast&lt;type::NameTy *&gt;(test_type); type::NameTy * origin_one = dynamic_cast&lt;type::NameTy *&gt;(test_type); while (change_one != nullptr) { errormsg-&gt;Error(pos_, &quot;change_one= &quot; + change_one-&gt;sym_-&gt;Name()); change_one = dynamic_cast&lt;type::NameTy *&gt;(change_one-&gt;ty_); if (change_one == origin_one) { errormsg-&gt;Error(pos_, &quot;eeee= &quot; + change_one-&gt;sym_-&gt;Name()); throw(0); } } } catch (...) { errormsg-&gt;Error(pos_, &quot;illegal type cycle&quot;); } } else if (changed_type2 != nullptr) { type::Ty *type2 = changed_type2-&gt;SemAnalyze(tenv, errormsg); tenv-&gt;Set(symbol, type2); } else if (changed_type3 != nullptr) { type::Ty *type3 = changed_type3-&gt;SemAnalyze(tenv, errormsg); tenv-&gt;Set(symbol, type3); } else { exit(0); } } return;}","link":"/2021/11/22/complier-lab4/"},{"title":"complier-lab5","text":"10d79030e8222445804370796b90fca148aa6855d970246f117c47b7ad826a663e7a448736ab222868572fdaab216fc45ba08ee72fab6b1b422a078b549937b01375303857db3de2025ce0ac6f5ff9325da99dc570041303572a6f40dd4bab5b1a265c8cecae0682c26314ea7b2a06ace34415fa926621e1687d84d66ad97c8b2a01dab385fa8f3ebf891d89ccb48209066ab94c0a7284221efbc94e3ef9efb462069e279e4f2806e6d9600b0fa564ab91ba1a94c97fd846afc2136ce02cbff6c9cf59eed3e4bd22d692ee6366066d695da3687663ae3fbc0c1a8952b814ec9f49fa2834d7b409e501298fd34053ab386d27dfb77fca3fd715e00707d589069e718fa52c841776b2ca5a2473a7d97154cbca7fb38b59b07ac5fba6e6e718c3e642d838b76f49eaa1abe8e118c5eedd637e5616cc74df7ee67af98d529c1abec382a21e4d46ea8d4cb74c5689d5d30496c396344b93228152864fb23a50e1a341990f980df23d776d192a0874de736eec0bcf448e0b6759bf2fbb40228352656126e9bb62d408fb3a16f3f5ebc33ff73dff8634ec99232e7ec800de507437316131d618a1bc34141b1e793f8559362737775b2b770c206d65d68d0627d91ba9e19fb06b9d1835841b2cf40dd6dccbfea82e00ae8f7f115a3f1a36f562bf3a6fc53841efd6956f3f6eb18ad06ef72c6f99e62996582ffed67fb5a9a22eff2fa47b4c8e9c7e42e5d54160a632fac75f0edd45c84a90922decb80d68d9a0caabc6dc32c986801df7d73d5ec14915a6e33af0bb1381578496a3106b6f005be3a0e88f437d7e2ebba1ccf569cd0647b737dfe9ac0ea04adc259183724942888b95e97f34cac403d39969afcec61ca6545e93164fa5c7079ef0628450b608693158e3086332e403878a692ecc484af219b6af709a8c118ec22bf06684cc10a5d552e3180369768f3f02a436eed0374561996dffd5085472f0d63c7ee3c7901b0f985b6fd85821cffaa9d32c292de38b8979ecd2565b4fd1d19e812f2a5040567560d690be7422a4d37fbbdf464f1e6d34c452da3fe88a388eb2dc2199713784e1234024c4f46c4db832c651ec1f6a7a27e9c4e84ab6d3955823455fdb3deec8dae44eaf152e465ddf38510ddd7aec5643dd9dc745b95bf9597c769d1a2913e7018a17c69684fdc05b0fc88cb3e4c628b3c5c7baa11033be47278f395d2162c65d4e9f0c024ab6307b88e08aafdd3ac5ee40db76039ac67a90784b42046194d596671834619120527cb6c36f989e844395b23895ce9f6019b757cf7845dba84aecb6a95c71332df36695bab0fd02fb1f34870e2c63a7b56b47f608bf4626c6a65d7f4fce238a1fc3f20fe1f1e1fb75ee84ed8654263fe29f871bb08b866103b673928c13fc03a3529a3ad5211b23f5532475950e509423b03cce3a90e083d969a82b64fceefc1149a3663647cee9a7d22846b80dbd8de6381d8bdc2737f7dba5b885e01a6dc148b9f6dd868e3d25f2eb7b6f2815e941ec671ce5185e096f3d099c311f42d9e8a761b66378c2427b52647ee627a156dba0ab5873375cbd7cb85f3bfb9adbfc36e4f85b5c62fbea16cb84735da416b608280b641a53689d043f40e1f6822816e96e525966457a9eeb2cc304d72f18b4c45cdbf36bd3e687c35b712a74a6252f42e3ede2cabfb5f9928e17401515f8af55d7608245049e3759fea2bc163c97394afd53d33ab49ad635dc96222d4a2386cad4ba889c11b571050a3803a52d676600ff49ea979c794afcf6fb6db8d8c02b1f747f699fb74a0dcbeddd7990190d1a160e7a8f7ac6066ab07c44ba30629e33868701319530ee17951392dd657bc5593cd690c114e7a1cc3a297d18160d3e18335db853c7be44903b3c9980d5c7f1524da20ecb7d0cb81485e56b801b1e4c260d26f1bb18b54a5d3fe498b89b94a01b9adeb8d46114fdd4045616f57fcd99b4a0569571571b45e8ffaef7969fa05f40b2ee778e1de3731ec60873e962bd9fd3cc12b17df3f199a503dbc8a92eba3dbdf93f173e70124b126d3244ff9fbe45056a2219f96e2368d38665f0449fa16479085826d9317ededb3fa9b3c2ed2d0f73c67d53c30df0b90fbf77cb884d680dc7fe74b17bffae06f6d56f9caaf9c50a8a657569ffbb79202d83eadcae7ebe27a5152f6f4dfd9ca02fe81caac052f89aaf6ef9bfaea7dd3a88bccc2c1acf22c4eb1ab3f059f8e80dbcaddc287d10f90a07a518f0c2adf561934290df0604cf92c0ca1592f194c933c4605906230290d207d7a45afa0727849aa47f9b5b66b5edc6b4225015562e493543201674bcbb5534c49d1a0fe1cbdcf08a4300224754076cf655de7eef357e80ae1d5f4db828aa373a7d6cf3619037d8f51c8b78aee1eb10bf6827d780933d7e455cd0873b37e1171d58c2d0bf70e3c83e02f7ae2d1853f1ed8a3c70205ff714751f028c3c0defeeb4a25150c243aad0c0c005b176eace8ddd384ed1cb392714a3c67b21e75ed8f0249ed71f8e5b2ea262013d64cea3780ffaa8c563c5319d0e1e77d986e657283a480c958e24ce15766701c84ec7eec261a4a1b731fa7d370a4aa051d69e7d469989dfcfbebba4224a8cfa0b6d221e1e3d15bf4832727a3b232bd15e97da671cf6eccf0f8e059027c76705afd7e0f16b94e3ce1ff64dce6541f5356009ed991847eaa3b6f7a687876d88ecb032a9a656311e540b2b5295cc7706a1373cc8372c11bf40881f88b25ea0cdb26c6f41392198bb8eb6e5a0c6603a41df578195ff1b920d8c15e7dcf8ffed42d5b5820ab2d34cb92bb9e97c21d1a887cb12530b4c1637ee6d96f5d2a87d2958ff30c2cbb367b1c2bf47d3481e8b5f15cb29a98626a8cad7f3919c88432f6b5143b78a3c7e730c9b341682b546b731fe6672f262975d859c268afd14a255d77d7a5d4f9cb7d39ae8fd0839c5aaeb29429a92d882c127293b1f722091a10c0a1561a17b9edabfa5fc8bda0a51f285001eb46268f69e6a1ed2a1ed8ec498f8d371ec9443045fa746c2289cbd2ad018f21518b67861d226edc0d166ce61813d438cb1e089f99f38ecdaaa8d5400138356bb8e8937349dc4ab6c1e6de5b93c194ba37e8f41e55c6432651a1af07c6adfca9ece1c1e46a14d4cdf0b8cd9d21d2b634e7ef4948ed75ea891b6b5779df21467792562c83b047a53258685de4b8eff5a3b038ba0bfc1817b8aa5347d0582b984cb431be7949f9beacf21da7d2ece3e335a897e0947bd8cf88db3b57a8988dbe354d246f875403b23b9ada61e202488d58357c069d9c49dfe2b56487c0fb3138f0686fac6353d78b7658e0e45314af30eaecf70d7354d342676787b6530852327069a9efb645a5436b14e9e8082fe138625c164d9a5b866a9f3e09709785256480d3f94399b102954ee0d4793fe373cde63542495cb4edc35bbad18738c03dcac68869dd638ba1779ab7d2497025e0aaffe87d8f251f66c263e2ad7a4a5b7cf1547909aba6915cbd195eb2ba2ab27112aafa33653d7662c0eca578604aae26c0929078001b3fcacdddd908c4b11f73931c66986b44dd8a7117b72360761ea4670ef5f6bc9043e6c0597b00117b905b0b2e6d2d8668d5d2aeab693c11a2b43ad4d98cc7bb27527e0bd76a88d1ab5a403e2b389dfdd19cfddca2e317a32237806f632cd507efd723b4088712b34252d2e746e0819b3917ee2c467945773dc5b41802f7f2d11bbeac9e349afdc90be824a23b409211d657b6f3fefd92ce890779ec49c5de6fa0a865abc0ca6c6d9a6adfe2e7d21132d663c9c653e7f6a7a9f889020b74fcaaa13f70b3c77f18b4a644d89db021dd3b84dfb6035e1e7c62e86e0d9dd625a8f0df4dd4a9e1d67550d5fa1ac8d76925dcdd10ccee1dc97e9bf64996ff5cdcdd0e9d58c106934eb6becdc0d4b9d99d90951fd784535d7afa8cc7adfe7aab03ed5ca20ac6dcd229660025831cf6e0f15c21355740427a152e04a99e14d7cc56c040e19655b634a4cab5d774c90b5b4a30e0153418f1b21c0113e26b9f710aa8615ab214245e565f4e2240fae3fb0fc95681a826aa7c48a49f07dc6a8509f4dd4227b6d31d1a984ade40119730ab78fc0cd0db914750be19f95df7a8e63ff941f5cd8cd4c9e7cb3aaa86527bf5ec0f0bf2d683f6571368e9c54a63f103393a64429768c18d57d73ff9933faaf9fc7066dc7df5c53241ad0d9a43b150c9946f30d14535cf3fff6c0fb7573b8c2f583d0d167c65183b3d7d53cf051f1e4e4608a2348ddb0d8c1bc2cb322cbcbc8d453c027c66faf8f0f8dae05ba93dd7769ace830d006592fbfbd30e0bcc1bd3a8d0408269df527bb785a3791e63408e9884c1e10f9b7e7689b9fa32aff11926b53f7941aa607ca71f398ae9b2c83118d5cf53210ba207451baf82525087ac64229ab9d7b00eb99191277975f5366ed5f2f53e5e041bbe1935e042ab862ac3b768bed8c19243bc77cf7a847097f00e127c0ab07ce938df20eada515e9d55446b7bbe862881fce9919ca8497f1abeaf3ad44f10813672570618116c7b8b80c2b209db5914ebf9ed9cda6320604231d9a8ce9f725d00dc42323de668bafb3bb58b1f539f26ad9017951b05df74e7e0ddcd48d386d0a53843e2ee73315340343667fef86b3b834a5360387aea4dd2a163394ffd18416f67a50a9c8c020b39f7aa0c07395c3e0c0d44401fc003524e551f63506a2d3f285e646e23f78952f7969156daa757cd55e24181114cc24d6eb2ed4e85a59a083213bc5ac511a1a64cf8d0126c5be1a4f7f418c287295330fa24afb7d0e4734d716f5b07ee40194c0549c0ed3796cd93c093bfb09cc50641975600d43ccf8e688ef1a838a6e867b1411e646b2943bfcccc323f31c64ad0dd905afa8713fa59c3cd7ac6831e8e6a436d907c2aff197ce6db8c6be4820516c19747f81cf2f80276f84493dc84d49002d68398dd234788c9f16348cc9c635668d965d50e181fcb4efc36266c95958ff8efc170adf59d0360a7400190caf0d380afecb3d9340447bba680ed0c311be50679d841549a404b35c7f91d464aed1802d1de59398da3bd18b8aac0f64aec927abec7f406684edc77c0b7db1e9d7039f9d785d73a12ceb6b14a1741b34c5072a90e8fed626c5fe5eb29fe53dfd78ea08907ec4992717c4d2716468961d3d581e55640246869cfcd88aa472800fecccff7f8019e9f9cc04e6bbfdd055adbfaada639af42f2fa416be9faca12dc99a3496a15a92f198e881b70c6cf7da1be1a18ee236d5f67861dce6d60374081c30ed99b9fb461c3449bfe9aaeff6b3e85b9ed97b1418973f3a96861822a1b2a8b7c111420f4d2cb2cfbdf7c4ddb1e100d6ec4a0b7d35e8727533766d64823469cc9ac4f34aceece2ff38c16de588e343339e043bb1aaf8f373e7f981186cfe667e66a5e8699d0a4cf5618fbc0896b37bd092de1fc2c0c564dc3848de2fa62b9bed5d2ba102766591527bbd19695753d3b5f84abca7f64537cbe8f778a3a395c92e2dfbe2a9853864c26c4992efa98316493a6472c446c9b8207dac4f968c0bf36beb22f56761aa3da0bde6f74b82ebf5321a8e7f8a2bc55e14a188bab685803df50395cfe11f41f58f9580a499d4292c3a6bc6337f8b26545e05d2f7e18d4a121e238a8ae9e57ddd92621e5abbbb955d24f3e34b4877297aa6974134feb3355078f91f02f4b6b232575b693f7ffbfca710883e121fad56b16fabd63bf08f4255fcf9be5e0e81938a5904814bbf681b24bb32d750affb79a9b84b8c51a34a83e7a0ba14c596ef1dfcd61ca16b591e801a018852b7a0451936fb01251358272910b9065f41020a7a90566eba07a76633a28e34c05512761562929a49a1496d8887472bfe7d1675f9d9968bd2c15691ff2cbb94d426fff11e9b79cf598d108d8c9c653cb0a4d411874a14d6a7372ccb02418e0f7cabba54076d8cea2f695173c9c244846ce773386daf23ae170b04d024dc2b4782bd30adc647683422938a95e225e93ce7154d0b4694dc5caaeaf7f1ca42a457e351f72c905af2ebb5c31ebb360053d2d8421b21ac2896a7b5cff757e45731bc47061652b9a1c907fdf1e307f4f0a229d8519628b2ca33939940b4b5a3da9ef887f9eb8b20d3b13d10c80820fc81abfd7d39bee53c8554e9f5b160fd37e7f24fbf2860f1dcb998a22d7d3ca8278107bdffc1d59a6cca4949ebc8e7d76b2475e97e0b90e3c5799148543772982821562fc7f81914d358e1af09a0e3b10c531c547ae4655abf42c31db5ef641c0a88ba3d4285373cf20c6a7b0126af38e2d922373cceb2e3bf1ca074236f1d18476b5a31687cc07d6087d329b0e2789ea967a7803729c913960afed1f4989cd16f806d670588adea8ad63792c1054b98f4476896cc89ee260a96e8ce1ec8edcccf5557b4a4bec48eccbabf5d4e174fa54fbac75ca28139ffa8bf8384c174cc665cedeb1eb5190ebcf446ad8223c18f75bdce3efa3bfaa5c4f20dfbddc1952a4c8ba3f0b231666bbafb07b07453b485705fffddeabdf0b5ab660e771f205ee95f369e148c2f897fdcfdaaf0efa9b19ea58197e735ff6e1dbef7a32442ae27f9f0edba908f4f2817f91e3b537b429af3be645f54d5663d03fb94ad102c5d256b2be50993ade476ed712a7706dd4eef1c52ad4ae81f75419613318210d76dd93887ba8579a5a33d244fcba9a9f7e59519d99134265f0bc45abcb5cc8654bb7707887e428e16688f18cf10045a084308423cf344b02dfaefec215eae944b8b0b09ae046192441f029e9a2e1d9be7f9e298f22233c87887ba4830f75b72a4c156108fbf4aca2e8b6318ad42fd0e4e136cd9eb00e092b4853c7eccdd6de51af9dd9b1f10e16ffca00d2d52ebe2393aad301d061c57d737b46c38bd4624b5e1ba295e34ea0b3b370c359133707c9d8ec6518ca1eed96ace02cbc20c0918e86a0b8be90406dc00e259639d133d77cf3d3de75d2a7ec2bf2b9e3e1d4557356d0a81a4c040cca72f06c035b44060916fc36976da5e53a4c62fcbaa2577170fad66d0eb94575dcd801beef412141463dd40b0dcec4041f222c45ebcab8a21ca1a7abebfe8aa6a96cf53f3e41ada8d2c5cf8c16893a023cefa1f257bb0fd8f7da104cfad6decb3c7d175bbbf678feb1c75c6e78de55e8ea7976036f3b8d0fc94a2ab0608dabf67ac71d54ee4cafa2c9af286e15dd0b54c4eb569c3da7c4ea1f160f642c7314657239e2ba56ed2b38ed2f7530560954ee575974a79716fcea9c3d236993eaf39f5ec9802e3b312314a5bb83bd14a19b479a0d630a93ab8fc2343405b8ba0b9068d3eee7060d75a03a4c943cb4d8fb006101a26068d74c99f43bea9f4258d5d9179d7acb281029f1458b467145556a3b84347ad144bd5ad3eb0617f5c1e187d6d56160cb1b6888534b1a95121e3427b9171ba3cef486655c798e767596c7e56ea7618ceb685bfd84b863ae24df2fe672abb251a963e0350d29a5ae66013d71523169933d45b9ff0a22aababf680069e9780cc1addf90ec5df21fb8015752fea3b0c38eba27352fdd91e5632decbb8805701a4008891b453cce4a38cd2f7ab8bd7f6f8558611eb3c6fe281a493d043b9650e96b0086bcaa04bf1a44f98319504a87c3f8260e4be3278ff2a6b1308ea37a5eb7dff0f521373aae9949b04568e7a1a30f941b65711d5181ac9791d62ad294205794d51181e6a50fa2810bfcebf29bb713a85a9f3e0968dee28a88ac04b0c4dfe8e43a59163812278f61d684aa1b12f3368c8553fb782130a4b8fbf26683194bd295da6653bd25d0da9601209d096d6df95a5f6347424bc4f72b50225c4f3e5c11ac875620595fcc97d38b49d4a62d98eb19ce64e9716fa3b32234eb5770a4b0a0563d09f6cb20d389d11a02dfb661bb1fe23d2e09947f9558b81a8f8ba28ea31d5a7f65c88a5544a6a6d0355a2c748449afb3257ee28556454ed3514317ac20dd4160a52837b3f1e2ca20b7d2466ca07c066c828c37466f25dec5588cb448b1c4f5ba7524ae8e32be2e36519761a4acae1723522dcd8bd67014b353fb5fa98880bb2302f5f1a7713578065b9c073614d458a4537e6bb4f808175bd4f306584ea393ecc0c86483d2515c6fcbda188fa471ef32c64e7e1ca57299182b3417d489c2bc934e2580204943e3dfa12f8cc75d74d0ca5cf193a64a0dc12066d9e9267931b2db3a50d6dbd2e5dcb33cc7b484ece9a38d1a08798c47bb1bd1563d2e2e15561560f1de680b5a3337c003943208e5c004fc70d6938c576edca5cd5b4125752edee02eaf06adda59a90ec616fa773ca28981e27061d9e3e0f455f0b47fe1c2a55695c5bd76d32c23df117ddac01400f6d4057bcba1eb9e090119ff3e846f5e7fac0b6ded6ba00533903363ba3dff78fabf93014805dc52cdbe487996d9aa437d581dadafdbcd58f0585145aa2d8cad78cc8527449a6ca90688dcf47b39b256bf8e66baab527c4ff4a0f6505fba1d43d2b368e5a34e32276fd66f006b61d5aa3037d15958a10e4880729e865c474fbbf4ed0a1c8fcd21cf5a208755122fb076f73ebf540d3fe0aa414b1e43dd438c5914febed3dbd2b059e8b90bdabef35f72d6dbfe408ed7c35003e6b68a080ee21fb6fd0f15423df729df3f58aa3227e2b17536fbc39eb0ae2aa69ba48be9090f65c460a1a24c586aa713a95fd7d8fcafb2726ae49c1e9933b4c2b6c17c500356ff47e9930cfc1c60bccb265ded5656effebb61df13130124f01024db8228c53644599834f0263f38f550c77f5fe463764a4b18c99c87b3d84a172abb467b0253be89dd5257a0dbf37c57cbd119569bbc4deb8bccf946a9e5d520cebc0f90b789e07c98117f3004f8a5da6a2040fe5f85f101fd1d4ec70c5f4835839ff4503906488e225af17363a91a9432793597080d0b53311126a06c195329baebb7c5f0fd726b22c35aa33f6cd92527b2a2a6a58f3b631d4c95c1fd1ddce1c7830f6debdad4af9b66f7a03d5282b3b55e72e8523755d76c75dcb0f0a385bb566bdac80148a7e541c2ff66d0cb2d9abe9d472d5b869109c917ec23e06697f35347a6bcdae3872ea6cca0abd1d7924d0d9039eb50940fb4569d5e851faff49ee69964f3e6a1d219116413565110738765f67e20838a149fe20c6c83cca4c9c89b3946361650809c7ca8a1a9c83c1daf02fd8ae4ee307b4d3eeeb71a8353c7b7103b6a49c1cabbf63f51a3877624e13c4f919d0bb70936570f9e3d35c36e8d8f4b1a36dbd956c3a44e73b688b9d368f2fae432e235c743e856d269daad39f0a71d02dd9f27c74da69b78ac331aa5bac46094f565baf608778c3d63ceed22cbcc260532ac639d851ff01b3336c61049bf80df685831a0abc131be812aba0d166961dcd9fbbb5eca3c66ec943d8f45913f425d57abb649288ab9515d5a719544e238f472343f2aaea88d4fb6c3d97c6088ff4d488c233fc68f65ce2b659dfe2f9750a671aa4a853a28fee4e4b02a63644bc46a3a8f015bcc3e64f83c93aa5e3ad019828f99d4cebd87168d4033b47794c65b1b13fa04631264a142f4c6eb9d81b4be442b5d0260559481f89f518694a3a94bccda209cc6cf1731dcb206366af5e12ad39d1450ce3958205193676a78d4e51a76296a1729b3cdf15fcf8cf96c0d54804b33be4f9c077178ba80806548b8947a7e971b9e0ce4c7282e52dadfc1df50abdbbe35e9729e7b5aa7de9a001c4e4a0cc1531d0d089b08716a01d91d5ba796ea566638ebe4120ecbe76fc6ec8b36690ed5e7cf2c65746d67019c2300d3ba5cdc4be242a02efa456ba58196a6cb7d99775a59ab195979fe7aea30d11d354abd705c5e8791a03441997a431b2941b7bd7cee7dd804f02ce5d41779565e24c756bbf40089541a0d9a747337ae9dfffb62df625ce726bb25c5ab0fbaaf8db7fe044244b3c7dda72e937e618f269318443f11900761fc4fc81df6c9cb901d8d804eb6be2aac01874997fac9110d81a590c0af417cc8879d5cd3b6b5db81089c5c3d1db6cceefad34403a313cc26d916ecc22eae66505cf084b154d683579099450fb07f4efcd5a29abc4b68f20e557765f8d721031b8d61500ab3b2cabe407f16738d9976399c961441544fac58a66439fc73d8d2772bf5d87a5035c968f282f68ab52ea38e2051bf36808390be574556c4bed0bebe169e919cea106aaf02b3391cd71c17237c19c424c856ebf6f4ed27c7e41027199ea5bdc730701eab7b4d592efe3a7fd846556259eb3c7124270dee822d631dfcc892ea22e5ab6ac5e22a46e4812400823dff14eb8281f9884215c0a9ff9c98f75b41ba7adad1490959265687ddd7d1658c132b05fd19facf750c8f34c93d728776fe565d29731828e34de7c9b8958a5f5e67ce0035f7010dcf0b2a6d093e2c9eef7db4552bdc3744cbcbc6026b89cabade749c90f9660a165351b540ee2a5efb43ce768cd56520316c7b900a1d783d4a05d7cb2ad7c7e16fe2104e3985bd588979b724fc37f83245aa773567ae3156d1474331923a3d8ee3b92aaba2e9e3b4d22176f19adac2dd8f2419da647e64ab359bf696fd4018799825944f2d1d1e26ec72a700726db6015ebdf177c443086c5969b87f7831a16af35be31f457a6190a7fe448a6abf2fac8442558de4ea44e9bc1356d041aeeb56ea36fec9557df7d3949c5c018dcd788bf398fcc67c348e84af4b2ad240e055ddeb2ab72aac35e721dee8b5527a47b8d9ad947b3a1d30c01c495afa2af9cec25f104da9c8b337972177e11f59c73ebabb9b351b6cc05f6f109b78c9a50cd42fa9c51f8b454d9f98dfa70bcb7d541a0383ef10f86c52bb7d5a7bf34047a13e7b8d2693fcc3781746ab8507ccb7f6f90907e4c4592e4bfd863f1284d70e8911bd6caeab32ca994df6473212fd832026b780b2ecc980d606cc6e92cd92073a3814c6cdeb7ad9eae958dee7b5234d837503a2af83e67d04adb6ab76a41d682ce6dfeb343418df39a554540adde82888571c6c5ada7ba2ea4233b56502f0563665c91afb3aa3ab29c1c8e3d5fdae0bde0ba7f0c8c7ce65d254d3d67ef8f25418c1c90ab25201fef535bc32b7578a1b9e4ac93135e38a6b276ef9606d63cf816f7290b31830d33e7c5b3b36582dac96b9fccbb2cc4fcddc51ade1854ff3990bea5a7289a5ce24018df857f4ef28a93606cea77d664f5c1887bb4a16970fd1d39f48191694661fe20848d25aab999fb64e7bf1bd53f403f3cba205f7a9f76d1ff6807ebba859dc7732b67c5af15ec5d02d1c2938b9b977c3e61e054c488d7808d984e99e8c2b656e363f31f08bafae782e756c192c39d620b7b91d682d834d7c8fc2d238d666e236a15c938f2bcbd0d880e9e9b0b16d6766f3e0f1302fb420eafef04272475f67458baac92ae1cee58dcd8a119b906dbb187a72af1f871ff3aa5bde41fb841f737c3acb39b8be240e782cdd364f2e80cc8e33481cd462cf7fe9374128948a76eadf9ef0651cbd0342f366ec595af78e7565065d99f7f5902def045d76df13dde0acb8485d60a106af1efe3698933b767324ea19181691190d5f18d148dc32e74b511c08505e9e73592045414094799d120c9af4a4820c2ff8c3b600feca56dfd4947d14327bd0c4911a90404da6b81a7f9cefa038bd7b75f40d3e55e87d0021854f1f8966e125142dcf16891a5a84ebb8d555b60e727247da0963a6b9abf19b092d362603f96c91bb1dec0504c1a4cadc56200f416c914a8108e7ea3c90d46b334d1fadd279dad70f19b3099cabba5a6f6471d0634d33fd0cfb209acd9e6c3694ad293097e7eb8db4b6bf1b3d02f95729f0fcd37674971a40112217a89b49fd9bac1126e2e1b00b89956fe262719820449a58863e47d9131f24ff3cf0164822a01a1834f856f541ef083e22c934bb399d2515abb2b5034a488e8b59dfbcabb90c4b5a88a69be481f36b8c6a38c9ee0e2564e46fb92c2a68c7d63cf620ef7f2dab8ba28a548cde978e4f09eae4d8bfea8a32e2a2b75c2dfe94e77565a84dcab13c8b572cc64ca190846aa23b2a9da66fcad60153b8ef3292414bfbf49079f69b239a39775328c8342016ca4a0fe08456cd967b086e2bca9022d58684dc66826f1016bf856717560ca6df188e6c15f732d3e022623254b0cc88c8d19e6b20266c0137f2b17d9994ae92aa90353bb5263e6ccc65af75f92de531b921f93434134b1d4e058dd5e2fe087721c6dae52fe812e3c0746122087a63b2188d5696c62235ed424bc5c9446547e92b93c5e150c7ecec72ae499d03347066cc2bac3b34e4f3a64252c81828397669e8bcc686ab5c9ab450409950878807a93c124791e359a1c279dc4c0dad6cff4e7cbb0e226f548808b6c49b317591e92aa1af6a83a1a38ae4accef7c2210ca0c906954457ebdf6e885268b67abbe80b440aa700811a9c8ace6abe0b0d04d990f9f96de6f159df84eff809ac2a56ded600c57c741449c603ae3d510fa1b7bdec54207d72c3d26310e5c74fcb982fee0a8e98458e6e03585b438590bc6143043cace278cc3ab258069b2be3321cd9e98b506150bb6ab579a54e51bc8d49c6d54d06727c92f7571fefe15001ba927fe6d97373e5c7998f12ef7f3bff5be6cf78630c6f439c8b5abb84b049b57833fbfee6bf3c41a670832e72f83df3ae1f90f2bfadb462cf57d3b010a8f93d87e586da350d2845bb8d58ba7d9f1135476c52188febdf60d397589074c8f40cac47d82004c3ff43f83c20f22cac9f5275563a7e2aad728a5803e3b304f3b8bd75449fc14627509dad717b1b8c2150201c17fd16ca9f627bf723908d491e2eaf8af974497a8fc8bc688d41b92a7d60ab2f50770ff8201fff98e1cf1e10fb4129c326fea89d68314d1eea2d0b755ffad829d61ca9b7a1dacf6efdf455a9a482b051b5c54ddb9954770128657c888a1205264fca72b9304d11f3d637f329673cab52e2f1ac15c76188f0a47e4a0e60676f716880262c66324b7870600dda9f18f67f9037643ed5ea5cbd6e1f44e0e73bd72a73cd1eb3dfbc25ca7c09bfcf86b705874eb1f81154fe4cff1dffbae55cf271bf7cae668c32fe3eeee985c31712ab22e1b89accdaad5248533fa367ad19efc40d40e7a80d3153159c2ce765e3697b898b89e433097a4e4d2d89581dc838fa933ec41f89b793ec970011c188ddaa58d7b0dc031badf2c1deb8cda0b95139a838e2bb9a2b9affdb6caa9c0ba3bd4f4a4c0aab38cf4730fa3605de518e4982faf036287740fb34a3cb82b00589fb2bf5a2e43a4487a35d8b364a5ebc0006f87a1040f06412fb58d63b1b0a341d2231ac993eb24d6d37231edf0abe125393e4d1befa9fbd4f01aaf04e0b76d490e51d7e4537d0d18e70e872d5439e64e0e118c568abfe5cdb2903e401ea7233cb715416c5846d2c392e9b50be15ddec29966f8cb9861623acc2f142fff8c9bd2d385d336ddc64d5d2e8d4319787b6a8883cc9da78223283e24732943ba6a25d7b14ab6cd157134fdddf9b54e0955493ae512260a67ac9d813a5b7a0fa8c3bec894d5ab839f8117eefabfae96932360303b71638c5a885e2fee4a1822ac1ee597a616f3c424aea420c35936341856df5847e1c9bc1301b35745ec54857966122a87731fdb7dfe98c97a6e976603d21c85aeff84e1baf8e3081390dcaa53636145e719239d2df5f3a37bc2311997ac4d960955b95b60a86c5fb46e26e5de153cd837c57e2abba2b82506ba2ffa1347b2bec69818b3ef1a58cf237bdd17523d3cfb2c8f9cc3dc4c5245f31c2dede856046a80e2e1f8c3c478c886ae78372b36de4d0cb182e140028326f9954c0eccfefa0a7be07b4bfee41d751ec39f8ad9f7c543fe61e849ed9c8992ed43d031b2be708c0cb2f5d736d973b8072586c6e4923a63635c63d08b9ffa1b31416092ee8de5c98306fd04dd5f61574680f5a1348832c94027483065ada4b3f94aa3cc44d0ce80bae6d4b02027514d89e8ca1ccff17c42bc1fa2ebeae620049beede7456dfc0c1b55110df0b4e84681d5510288b7d0a4a3b9216ec23d6da26b5355314a58a295cfcc3206c847d5994b3719ef247c28e763c58d8f8ac240ecdf262c84cf0ba59ba286c47ea8af55e8ffc0c87663cf5d0a09c115b223df059cea44236fe3ad8b4de03a7cbb6c5cfc31b989e437c0ebfd165f15195c65729c7a11299fc96030e0070a59a090da702f1678918ab234c847841de061005af3fe21ca2ca77983d7365dce365167b10d6bd652aee751d61565a8a3615e9031b87a4f21b443869b63b6edf6727511bb569edd87b1d761224ada00fb3520fff63269ea1fe380adfbe1f31f3bdaa25f60e2a4625419f6bc11811cafd42c61322ce9fcdf45a8902097f48fef400b1ec2fa9cecfbf24b5bd3eed6161f8923102a4bc73c917a0c7aa3ee445047126418f7211225b2ca578c43f0148eb27c7851dbfe36e83e8930d03892f531120f177901fba2e8120b01216300aff4b2381f204929cb68375a91792e72c19370fa098eb967a4deeff064c7ad9244618081d470d34fb62bf27e6aa60e6d2464bfc976ad4937eb47773b36cebcf3f3ebb8c92a3a054136b83533fb3ba5b70b21c3277f86272e91349561e01adbc35abe9708bebd4cbc1bc7924e03f825ccbb01d41f45f0293dd8e231c3e81d6c174d0448461c5bfd6b18483f878152f3c898fafb75a3fc36bff6f6c1a2a6d4b144a38fcc421f245e134293b41e8cbb6f8f89e519aef096ad8a1539d838f0d16c4787e9f6649d551b055e59ec35a335fc37b721f05f464adccae6f0064fc8afb24ec92311cf605cfc898a8d914a916bd3fe8f6fede26edc28f487330df8ba3635eb059d3db91a05bcbab4c75150daa178a0ad8f9ca2e2e861de924ec6e12aff9d19cafaa588b9d150c65b4f9e177ea17a2b7c0e25e925d8b25950e08ac7342cd15f8f82cc731c624ae1dfa5dc59c6f7f24de54437019ab765eb67ae53b4430aa3da32181dc95557081669cdd7019edf827b3ac9fd64469a103c2eca56f3aec412f5651922c0e369e3c18ec26ebd0a1b1c0026a4dae0863b0b06ad39c40933c7e08b5742645851d3d39118a43cc0a775a06f5a27bbc92dc37c7bc1f2c6747c699f1a6da47634109fec74e1685999d328205338146cc93a73d02c79cd5947ce8ec18a41944e7080ef4971b0d6860d8283efa0a7a0af201a19582902a414fddc44daf1d3ca70dfaa21db4f206e5a03b6e1cf13243dc54bfa4bf459e9d21d5ac326b1ea50d47d2f48ceb03b573f5fdf0314741c841345399ef4b20aa9f1d05adaf70cc5528c0e10e090f8a38fca3a16bd4e6e9f37639893f4c384dab7364354b394894881d83f176903c655b973075ec274c8be7b05db980f8851ed8c1a1cf98e4ba4e0179f7cc8b6a2767d7c3d97666172a7d1533787875266868103ebb504026d71beee98b00e1525c622531b29df2f1cc024e8d43a1902d8d2c09c6e8067944df39b8ba5a9c4bafbf73bc216f17d4265e97f426d9014107bce23d189d92e57444f5b2e9a848b083debca087996cbbe4f8c055605dc821f9cbe4a059ce63bd7a0a69d8ac78c9ac04cad7e7c8e79e2629c1c1700f6848c2500dcc48a2d6279b201fbed8d2ead01a97e8fbd3261ab33185b61cd9bb37830f214c8547a83ae03be20e190bb70090b6f344034f3047232109b0deec969ba103a95758b23eefd03c2a2f68c787d4856883926810d1eb0af01a82b958f332b875a5d1dfbd92ed478c5a52ef278e6fb81cc4d4327515317b0d018ffb08d0d0a5e0b2b2f212dace6dc7f39baa00dd2d244900d294aaf8b4f0ea0f533f2d7b85a380d28c37e7f179abff9f6cd2e73e3edd8ffa1e6d8fb48e6a76e8935eb07c7cc786b3a9995d169cf55cf356750ce3855bc210f8c52780f42dd8d54e92f148b4fef41585c9b13654452bff5507f80532743447ee2d4d8bb9b81e4b6393276b78f5b9e55e487132f34e93ee2c198d4412e5cd9b23a2a1028f4ef62cd7a6c3cf01d14f7393999a3694f99cd7b93c877715b906f42892d136011f2c32d99464371ec5e4b6bd1535d0907da60815c89145da74534ceca4e29fe83a7c750e62072c37ede1ae0ad404d42fec236ac7d7ce5a847af76fe5e26536632adda37fb3da1aa76856bdca005a64048414aa6c40f18139affadaf041881529366f8ade5451648035ad4a2328e6041d9b3f1717119189a93e80e21159c93e196ad5b241debf98bf6b7eeabe98ce24d2ed6af4810f09cab897e3dfa0b7ebb94d8fe003fb3b77965579a6efd861cbe4e5e2dc184c79929d949eb12eaa7e7804d7669c22ac93802d0abd7d470e60ed5c28fed16cd651d6007df564c79a7b6ae047d0c651db7962ea2b48109b81807f6a70bc5e7ad1b3897ae08ebfa931004c745d929ec4f35c19a734bba44d0e7b6382fd7fb52f000e3398f3497791520b119928ab159fe4b95546541eebdfa198ae29b0fc626899e2411a10ff63a343faed5a6d5ba29779b561c32a82d9b2fbffc3b8e203a3b4715652c1fb121766aaab2f2b8db2cd4a9437485ae5ee74576270cf275fb9f08d455c9297f563d1691d2bdbda06ca47635f3aa320b48c8a76930e4be5117beeecc2365a70fc07e9473a9cafb834c4978958fdd450f5a5f7c6af9d36d0f6bf25274a8c9ee004cdf11b721358458fbb1376f533e5e74bff3dda5155f7cb89123ee7cbb329003c33ea7875f26ec4631b33a4c593eefe4003a37bacdad496e69dea4f5f60b484724fb3ee29afd9a2c141416378baafd00c93355383fa71bb5cff6956783ce365dd8743f81ae6e5543948029894c33d5c5d4018062ee4d7b58548cb92474e2488cce715e7690524e1ad78c021f9d19afe3ee53fc1bcb80c4f5997b90910bdf326e29af57976a5700df4a3c402b0317dd5dc76d5afd9a29c83c32808dd8e5559c2952900a03e4cf2918394b93d642d4a27698e50b045b41d1f337822789041bf71ba47aa95aece2f71f9f98d92d80f9cca6fea0499759f866949c2ddd4fd53b9fba8d066a6d979768f430c5d9769b2c94a1c950d88056f3b4497c86a9a362f89721132227c5568464f03983047fb29ab253e04d4e5e0b0a8eb82ab8624de76a39be7c1998c905688887f51e5fc79ab6b636ce9ab67958d6055540f3d6fc8c189ae824034fbcbf082782a03cebcae58c11db13c4ffec964da08d30dccdf166bbde584c249a09f5b6707236967a16b22a0b3a296d120973d4ceeef46222a20f2b1d84696fd74d252c36431e84ea798185c6a356ac3c64f2710c0629230c27f912c4c4f52cee5c5fab52ae79cfc0d52b9af1386f269998628e535f93c16a92ce5c78e04ac14c80056f9cf51e0c27a8bc113c8181010c4966c97ec1f42d3216996b8a1029e808e2ab3b1bd78dea84c00a811c9d8387962ea52aba0ef9e9fa7519daf6870eb62a9d334aa4fbf657523833a0fb1e6895fe5929e15448abb04bf7de71db1dd1705c7af40f5f80cdc71f1e8b59336f65213a4f19118e77a00cd53edd7ee90bd3a55c5e10450cfcb1334012ad2c915b05dd7125634ccaf5ac06c13ce58131db902b7c8cdc52678e052c8d98e60314cf48bc2b900428008fb0dbce0336b2952df5d4bf3e85dbbe53796d5391fcd78654fb117494e5ae85e34212f5d58f1d8ef22c835af053588f3912bdd4384b328b6743d571322dd20fddb0a096f13d225ec26d5fdee50beae019cebcf5b537b3f594728bd652e263a5c82a1a03d7e184b876c5d8168dab1a789d51ab80692b363f80544c4fee343bbfdf24e48881e32b9ab6d8b864354ac486d262cf5487f0cdc6b791d33699e0801d0bb7c83ad97341794cf2e6ba9eaf9fb0fdebc3cdcdf7e3d85ecea366bb9b418c498b623e17ae88eb9a5437aed09cd3b54b76940395d844f4bef174233da7ee0b350c6a91ff0c7cb6a101c16b03dc9be1d6a682c8fe8e2135ddd7a4e4f45b32728abbb121c00226c619eca1c063a2b13030abaee05b0fc721cf31cf22cbc3d299daf97a1d32e0ab4c2449f9fa17f7389dfa28cd91ee590f61e7ab361a7345cb6d2c1712b1d4fdf4ebcac0f2612f0927027571b52656191b80f0ccfabff27811f85f02b178d06d0888a702841c5f47bab88790d3d86a09b89f8c38863b2de1ff63582fc7250569cd055ef2fe68696c244c7bf9e6b726bff307d570a969d9ac927f6b7f279bbf574ae36c6da1f609812c812ca1a1c22f94764b2404717495560f3c6d70bca0fb8432926fa33a02d2d57edece1dd9feb833d8c130588c2b429248a8cac46788645954ef0fe816b993159898c429d62298763f2e23b9e0220e019fb83090f9c4b270678bf296c02c46d45b657022098264627c91b6ef787ec597c00806fa7ad276a11de1cf773c640fb6b83878ec2cac5cb2bafb58a8fbeba7be659d8d077c1160a0c2b06a73e3d010c7760fece942db38cf764f3b4d8e15f0169e6c2f9ad9ba742ee686042bdfda2cd978556f0565d5aba1ca598db9d65c45d42419a11913600a094e2b7fea81fe590b79ec2ed030d836c09cdc780582984d5aaec6cae834284502ceeb914639c463d746fe8a7a8152d31df9f413a9c9fecd6187113682bf40197b4043b4d1a69400fc82e3ec4d510056f9707e7cc2aa8fdf249b3ab602fd0d0940e1969563fda5df87a2a83664c63ea26ef661cffe7e525540eca86502c4d6038d4c7e820b9a2474a570edba2e4889c0e559f546f1fe448b03e9a0e36f4f5ae44cdb4cf5f3d44e47e983f99f8c06430c8c2e24b4ef0e7ecaadeff8cdaa311a18389ff250ca2c02320daf956e4872a291f545c0cc78e48a3205a111fce3ef1f49962656113e004ce6e0312d70ae7ef3169940081c9ce098b11c0365f6dd3f8e41bed9dedd879facfc9db5198fdb7e6fc53c2bf63e85899aaac8db95847d4d3595eaddcfd3f9f769e170c1d6ecc79bcf093c5369c87247858a8a361377f42126196daf0c15683c41a2b45269f02f33f3cd62ca014157f0607f1d78714f6b9ec700d44a4d13ef868104a7ad5efa567d07b6fd1e14e05efa685d6e00127f7e3a3a9b34181eb0235542acaa95d210679bb1171c6073d969f37111c32d694c314f8e35ffe17dafe60bc92799150b686c978d81f9152f3aa9b518065c23c74b21deebaa7b4a45753f7adef2680b2f872db30eec04479250fa565f7ca5b869cae03c740861ef513f54ba393fa0cec09876cfb8a9b6b0147f0b2d59b39419b00a445ecc90db7fed321f5e1164583f4287196b2cf22111656a31da31a5d9ea10b1824b21e6d31c0a4d4ad425b737ce0cd9d82994e2bc4fab5c1055c1bf9f963c94e214f39da4ec5299052c9157fd1efe636575b5fc74b0d2718531d29df238b3dd62340ebc4671d5057be4d4536f1a6b0fdba6be56d7d8e4de8cfcf74b0f9efa14702a414e2afe0ddab48874445623f3addf438b11f3e5eb7999ce817aafcb3c9dca4f3bd0aeec50ba20ad109271b2f0732298dcda146190f36032aec067ff2115df14d5c1e6dd99d9c7ef1d7c8c40c4bd6fd407098bf9290e15bab6e89f59e4de817a92289821b2373d2909d116eb8b7f6c4a8b84c0ebc4dd2714aaace1029db5eb24f1137c1a50907fd3a72f1dbac59ed02b02a33f514d63daec58cbebb6128ccb47713d1971c1f81f1ef2e016416d6ef2ac0f9d6056be7c07803f0cdd7e9a3e6dd15272be174142f9ef804977aaf286ca3b44c4f8a644aaa43e671279db3ed1cd7fbb4a76de445319426c9f607b125617d8141f62f39f338c01961e607ed267ddb6312a52840c2571f6e7d8d40f84693d143f61891c27114af5372f14baa6110cb7d757b67e3b8bbc078e974bf0d07a317094b43021b4326de8dcd43cabc6ab2aa839ee246fc452ff83ad5e5f4629042b575168bdf8bfe28c43af81ddd9e12467a04e24d0b2c40d8f48899281af1fbe3652b2259dac13f752291b844245ac292815b74fd7716e6c8a97ee9208205ac6bab7ee400bbda681079145101a0189e5823cd689da14a52d7d016db5742f9a164c11da4f3d1b3d14f6ac847239345a00e5aa514665bc443a4354d64c5474934a430b1a00a1bd466fdeed09a41422defea40770159630997f87e4c23d2fd0190018527a400abf306109ffa4b5855777f4f3a1d4cf6697b94f365ab5be0c64d2320d9dcf50ba61f9f77fe5818a790da0bf115ab5af7d0564254088f262fd4e961056aa8b977e8281f4aec09557b5be318d01434b1268c4aed6c68a3ae92e2a2a8e59f42308e36cde45704bd3cd0433563a6cdbc10c0629ec961196cbad908931f73d5d278775ae302df8e3c3c0bbb531cb781a5c1f9943dd5739ebd4de717bc312b2512e4dabb5f2cdce0caaac85c75bae7fbf06a082773aac1e9d194dbaebbe5346ee1b743508502b3d7d64e7c46a2ce1e8efa146d9b2ed8f9f8f9273bda738370e8725622cab6d676ed5797e3563604675e587679fe5449a301c9f3bf2afd4b3c8172b1c561443a9ad5bb6f196468f28607d1142603bbe738ebf16cdfb6b4886084776181655accea40574cd8fb18334a67f870a2d7ef08ad4cf8abca82af70f163f8356513ead535efaf7079b21311d578e7ce807afe9c14aee0212e8366ff6a24eab9eb81bad94b5e8ec82054b704485eec197b2fc4cea30fde0f1481a9c44180ea183844d3b608c16ebc9d8a3c5d6f15e1036435cb7ca25524246bd3aedb6a52d0a33890f1f0103c38bcd3b9aa8863b5279f7b8eb226433edf3012931d476614dfca910bdfc78cd2ff8576ff8d9a65e451a405e989a805e53b3ff02549890324a68a4c18caa28ea1f1bfcd7afc2eacbd9e65a66016b9f777a23ddc4aafbdba28dd0d93cacca224ffe1e83fb6eb8d17fc2e46933be04aa81044ed7f439168938c75ff4a69b2e25f47df773eab17591a0a1f231875470386a189c1bf4129e4c2f28bd2efe140a144e2a1735dbba57dd79deefae6ee854852546b4777e453fa119760e1a3459823cfced9d25169e775175fcbfd13c6599d2d8c4fef2074e77472637e565cc4961a7635550487aa7d45484bc7fe175a0d60125e4b6dbaf274f6c22ae6d8e0a08159eb4f8b6400d8cb268a44d462eec5f67de0b3b264c62c90c3c76a18247b86b6edfb748c28fb46a932ba826283a26ee84bf5d9bda6a7ecbbc43a78d3e15e942a1332ec99e08a01631337569a1002a3350eeba14fb6fee95c2bb1b83cf048fb164fcbef5428fea27e711985d120dc60b5f370ec4de193221376bd2b77cfbca4e16f8eda16ddba7bb462b1b010ceffce4ccc4c270a66d8052abaadb6b272b17463179e6e6975367ce4c9e8c126eed1e3d39f966bc9acf3e4500e76b53daf854222ecb75097be8e7d0f998921fb7b75b415f17edaefb43627bbaacf52ec0dbce1e68a718e667a5d23f30f6705049aa3a17cdc3680cb21869de218676b3843195e2fc46af11e3109fdb0b4238e86e9c10e80b2d837c99073e98e95861448833240201f4eed13fcc3a85f7d852db17929281093a8edbcd8e91c748d18a4fdfe1f4a6a9e6d35c22936a59b08a5997dbb1a3a74422bef38d489c7dd87d7d02299a23319e447a8781e6464cd0efbdc08c46a2e81a28026bd6142680643be121aaaaf0446d64e62d93b4d8fc8ac7809892b542011a7a23ea6ccf525f806c7795223d2baa986ceaeba936b848ee80033a9a2340a474b51153da352c0563ee6fdda0c434f6218e6cb5db17d7687442b1165512429124ac3ad329ad521c5ec3f3d7ed6f7b78c838c7cdcd578604d3090ed418e3e9a626e05d48c772bbd026112d0cc56da174e89a9e2144341ab49db42b595bee77f231f009aab1b6627585352845fa1476432390ab992e0fb8425645e255db2714fe2d7be940516391b7ab7dfa57439c605bf9b665586e1bf23aeeb7f8932dfd610cb40f5ef5d68388b8f55a0665b42db12386c4f897ea6b2d97d3d5158ad0c82378a9d7a0b8cd8793641925b9ddb64adfa39999e2c9c5184b1c433b5500bd8c2f8400588d146ee70b988ab604c2f19daa6d8e3c8a9ce8627ddeaac82440c4834079d16913d7ea1f0bd38005c6ae032540662b64dca839dabdedcdbbbe920dc81a781291193c86368a48d84da4dd7264e5a18b7fb151295625d5c09b96b738b911e0686d23052f46d08d430d29587858322b65a5d63ff3abab60bd5d7f57a38a523465e86bf5ea1c7e021f87eb6ba3158bedb4361694df0fd60b1bcec670e8500e9d85bda002b0360a34aa016d8c54d9793ca9a5b9f89e6e3ecb6d10794dc1de5aa3b24b9edb2afd018a86dc9dc0d12989e49d0d1e3ee4d3dc9e710a84390c15d7ef8766937b6bf11055da3b3111a08d7edc23c1c7f22a0350179031d6eb2e5a961223b6034e50d8ecdc21c6459926c8cb3c49d9d5be004f6091267253cf1113a5c6c8416cb4569613e7ce0c2604970df547c879c4bc3511ade2216c3e4215e185ac624e1057b6b7abb5ecaf567124c5c91f5b7b7149ee095c94c219082919526ca301d9e3e397ad30bff30bc545fea7fd52b7929cf6b8447402bb41ca135b94cdb7033063bceaf77b0e18ae0b35149b423c69c9e1f75ccfaf89e896223c8e2aefbe0287a552a35a02992459e98c564df02da59d405ca6d43218e8e98602ec1145d14effa04a2528947c887a9a0dcc8f2e19503b71060994736f8dd929f66d334c5787c4c8073fa11c2f04802c443e0707e557308c945e7a6fe8adef371bcedfebd7750da143394ae73b8260a16b5277a2cc86bf0202a650938a8964374ac89a9af1b4f1028aed18536c6ffc8186bd3d12bef3842d66f476dd77e503a36a13fc675534867816eea08a90bb9aaf9ca23253a552f4dda269dc418c69907d18eccef16efa659e39c44f8641afea322dbcc9ea8f0519841a55e46a20ebc0fa17d6a5458c230c292ccd6296e6f53a9a231062e90d6ca1e191dc7ff55d67e5547b38b0c0ca695f1a8c084b910ab32619360c5174cd441be1f35d171d17f42fa8cf4510e2d4ce89e5a8f028762c75228e6d79d217c88c3ca05d0d2b800b20b968418915f9acc62662935a14f9af1de0bf3f50b640a7fc14ec432f10272f1ad042085293c2fc92979288efc03a220c2ee360c152cc6bc659292d9f1478b41a362bea602e1c1126cdb346741e797046617724ff3bc58aa180983fbc1edc216f699f1e4e661648f46333fcea45e1c37292e00069fb8ee1b5abca8608271a1d2c37d066b3cf1385846449d1ea7f35473b7f3aebe5e2b6c2dd55557f22cdd19f1caee6b680871b2d037bb2bf8b7861193626ea1ac81634832c343badc0e9bea229ed56cb7ba7bdac72a2ac298eaaae08c48c2fd2466a6a77e4982b1e27f8ffbf17a564988e11e57fc84691b246ef5601377550fcfec2517cdabd156becdc00092a9836d3b713dc51c0f28dcf1f054d5943b015078176a9048bfb55dc869a0664dd3fe868b45e32fa2d220a4f62d6f3f793f18c5f5a6acd41f5319866988dafa7274f3bddad6a70bf92d5aa9fbef3c3b885cc2204ee0208ed05b80bbe9fd18537984f3a830c02450fd67e6c80fbd3aeaaa26edbc5a1eeabeac11eb317a35ba7281574fd3c1ed7469f4bfe1ab9902ac105dce32fd53f755f6345c1f49b6fa3af0a413714a758b382910ebe835a0f96c195ffc34b0983bea48874a097af5253bd08d7dc7908f1f21dbc26c1c57baf6a95f9b30b6bb73f2fed4a7b75e2ab0076eef4965eead3d939ef15bc228cef97e7d5645d8bf989ec0df42e89bc4e741c17a8cea1baf0ff063f2aa8f0d260dc8a9c82f9020ed00699ac512d96963519f563dbd4cde12e3daf2a6975678439a8039e0ae1df6758b893f8ca8d9848bc42fb335fe2686086648a953a002915a6248fbd9b9e03b1773be1db56de32d483446664c7e312939e1f08178e9e26e923b3753ba4e2c9a3480195ea68a56c76f76ca8cfea7edf700d6fc59062575ed86d379cbb35abff7785b777164fab02073366e3d03c4de57a3af99b96a399668db3618beb28533257a3df7497d779a3ede4564be18e834b86895df937d332daf8cb44abfa199e09989a3db5825bbf1bfc5e53b7123a86fdfa21b36ea32d4d928b5fc46b016c19cb6fbece41ed65ecfbd4ba92c0474e39dd1828f63d32582eb9a1acae7a41b72a23a7ebf7c9c41403e812f3ae406bf1377acb71129f27bea070414cd2c5c7c2e55391dd82ad3c3a3ed87bbcdf09ba0d0002f4b1cdc76fb092c4d55722937db115a8213eb71ee5522850555fc548e44fef7724af6f797e2bde9dbf7b892ed899c135d02f36a27159a58e6f7606c3480f77adb09f2305f4d7ec3abee083991e9214f552597a63455799e127a101e4c902ce3ad39f5d7cab4d83de98e0e5fa4cc5225878eab3c6fb80ec01d1a3d234616b346e434e1d4e0179cc6c1081ca26fe038407524c683eaaf6b10f5a8bda6dd2f5cb5c454355edfe24fe6707f8e72ca1e4de016f7bc597011646cdcdcda2a75b49e3109d2623ab045d0cc561be63f8656aab1c3bc0dfee661856c4d1573413a202cbc2b9a7fc34c91f435003f2b777fe93092d93b8a94d54380daed839ea2603aec00cad5831c602dae431acd34f87d9844c1432430053a5a42202c3bbba24e74597eb197e68ef24776849c1c0e01a6772fa0c35cf1883f56be130599954c73aa24187ae02c29ec5aedf9320a00f5aa7d9ea5eb38866654e5bcb169faa7eca40ca5e05e52a7c6681fa230f46efad6f48f613a7c7c80190b9a2c50dc501339f25c302fe819d2628c1e499bb1f2155a0bb22cfcbf8001e9b0f3a5e86767183bbbd61014416022d124c9212f31c3103df846f8a5c8daa98fd9641847bfe1e69972e1523794a51970d05b105bb367219ee6adf15bd72d0aac4d52d0653f8634550147b68bc90fcc860f15fe1b9fe27c79e4a9bae774e8aac9163a20659cb6d5815ab21507d10989aa03d6e111c0fe29b97947a4933d9648381759e53afe50824614534ee386fd2e58e7a6112dbadcbfe8ef87d2e949b1c68423bee4acdf1bf509d6281a8351a4a8724e22b2539053b328b7ebfd6d795eac9171500d7e7767faba8d9c58b98b8cef0e6f0a543f810324ca7e7137233f00628fbca45c886208b0078559cb2d961f34e6e0b461e49b621af2c7aca77c9cf433d4e275573c3936dd1adc9d0e59bd3f732499f18a427d257f1579e98d35643d04897dfe7940b982eb482f2c5de1c821db7452e68cca1ee88e16c4e66c8a705d85ae0302814b81f4b299b73f009dc6c36b773ce5430b443f05de367eeeb252bb5d1f468944a638eab61cad66aeb61878db1c6665443622eba96805fa68ad9b7f85a57a25408e72b1fef614f7bb6f003aaf5c16e15c53861c8655092ffe34c57eca48f1b0419fadaac192c00265f4f014b5fcda8ebcf297a5183b7adcf101317de5f72d659750be1f01416941cb989f39672975c810d0272d273626031a13adb27dbc0b7337df4be343cdff2548a48b1af450ca7c195b353810492ed9b19410ecf7ae07ce1cdddb0ec9f38360122d2f251602a4da132461403a74d15807da97da61a71b91e6801d20720fc0871f7b65fd451d71c584bb19da91e9fdb6eee804f9fee32c509bb03121b7bd9abc7a8438dc9d4e872345f349c67f3d2f4ca84a4d6c7c53621a2a9ca97aad1f5b6b7737785c923a2dfdb63d11f45811c4a5387891c752cbd9f1cfeca14aa5b8ceb5f903561057df8aeb0a2a6345ed4bfb7dd73270f7436d8066c6b2a781929339eda8f5afb0c3fa9e9d2b30e0be16bcafb576349737a0f8a0913a60f7797d5a472728ee63396ba2d04665ea097df306c8a8cedea23686160381a813151f2c0cfcf9c7ce9aeeed64dee52d93125da3fbe1bec4b95c3098f8c89b9c43ad5530f80d97c9a35beb36117626b8aab2e6be4cbe45f25f427311a0963151be4a2be04af8eb7fd50f599faece9721c4309aed3394298aede5a4d81e710ce8f82aa5ab2ad084a4b55c7a852be3ab9df6a767d19c509e6bd7ba6b05a19e074e88cdd60839d47d46687bbf6d3e81464aa593c81842d20bcf99cefcde6a1b5b349578c6e72d40b0ddf056d45fd1e7ea2bc87dfabd109c70561f63c65e0099fb26e8921d19e769cf977d38b1e42aca544fc90fa8d6d9f9c7530b08c7521e0521aa1cd3e2bb0121b32876db54c11cd8d094ad1120562dfc55c8f1c74c0ebb2776242929e329dba2b59d089a5a29429c67dc28881288bba1b97e711ffb544f16f9b020ea3bd63871a516b582a7acde9ad703e702f735e9ecf3240742305059618306cb2566904f7c49d56e9e684c105c201150b07a543dbdaee4de19356647159b9d05c4b7928f1f1d366f93251b35d573ca4780a3ec73930fe3e9f3b3ccdaf5b7e3e898438aee9df0b59d249a111381676d26fbcdd1d374a76509d11cf4efc3a42a36b29e43dfd7b48f73899d0392aaf1509b2e11f63cf26591bf92b06b56ea39cc76357c069695c1e624a205fb876e9f1a838945b46d5b0f55a842d46974d43742c46e9c892fc3817d54892f8486d48951222e0622d99e92be21a898bbc4bef59d78cd817a47a4f85bf663875621b879e00914bf6dd2fe66850f4d341484e2ae02b9da26256c473833f620adf019d2d279de37bd674f13c5cc32fbf63ffcda6146b950e8f6df349ecbfaafa713ec31c1e55762bfd6caf82c60ad8380bfa7aea835df3cce5d57a0ac3256ab8ba8cbfedc7ad8a47dac094e0d2d0a208cb9fcaf303e5b4513154d72da75eba159348ab90d58d533b706329f19f4990e703f0b096fa3d9cb5babe646d3bca0e18194bf8a4de87d9778edaf625948ac2163f29953c8bd6e8d65da60f72e29b03a94405523d9cb9b1761eea7dc0286ea2667c3dd94cecbd12fb0a9977d9d57827358139905d51e7582939045ba03a948707e5bde65e5300cc28dd9f4db8b9d862dbedc6dd6cac8eb09e56636ceeaf8b385393ff6c14823296de8149a87ca1d134406954e7e3d899bff2f2c59c6686d73e6068853cf1ba6b9bbc2b6fc9fa75549d4df4ab4047cbb2b017f2ae7287ccb98faa265aa4c658a65b59bd2bb93b1670017074b44f5e4eb71a7822faf54c380a2e9ec28af3161c345be57568b5bec9a4d2a7816f3bf85fe26ef265ec6965b31f23489ccd31d2ce3701f6ded4ea4471bde003563d0aea822f11ce70fdbdb66cc36b4a9e8fd3f226f629fe5859105ed296d6e0ea4b351cb5d15a8d5245e4da318ba2eec391c156bde0cf6e0dc0f8c94c725325595f3618a9b222dfa9e87030dd29b56636a8271a991bfdef14fd1228e582bbdcf757b1ec19eceb0c5cb066e66b23cb507654fee8cf45a6587fea2d862bf9b07de5604ce4467ad7fc3a6b3e19626c0a57a9f1c66bead960168d4402efdc6a6fe0e7b7881fed714cae62f02e9fc7c2ef9d19f797142949f7748c514f886dcce7a253e2cb4b1798893392ca989818eec0cbd7e6fe00c0d472b7ca227c13cb97d30a62f447945da89d236aa1fb8502878c7f9370d8eb74f52111ffc48cc85fb1baa844888f8f09dd340ef6a1c0756d697a2db12644a9dbf75ba1136a227ac0b36e059216d8826532693a02be235a881c92be87fbbbc00ab96356899d7ab51d407ee5d8222adc371840aac2bff2cefa17254c4670909df5d1d7087ccfb351d961d6bfc7562b6f87557eb445146191907df9eb88d5f772987107c6c64fc77417b4363072e27b5a40faafd5db5bf1ddac64d364c06abab188b85837d1a5c4321504eb81233017eb7e8f17fae2a0b1519fa1acbd3e06fe1c791a305e28f0c5f084d648626e3dabc31c9e857860494b079e13f04dd793093d1f76b698c311d00bf53b17381f6228417527b4eb84316551585048aa141058459543cd0b0cc77434c6a177bd9185d8bd3a42dc91d7c4b7260601979cd8ad3876eda979abb032390c93af739087a680912529353e585292b91c2c3541676fefbe4e347655de54256647cf2c19c4f90c3465c9ffb2db2ea683a284dfd4600732a80d1b2783370a562ca3904482e6141eff6a29646776e3c8e5d58d4e1859eafaddb3aa8c3124e07773f3d6d816cd0b28c3cf44a7bb9578d946e0cf543c97b05308b91cfdd6e3fd8d48b92c1bc647b19c899bd868f0e5651bcc90861feb200791a00e576b113abbb10b1ae955c3d3fb2198a86b3a54f0411e5d8e189ab729a94799613b54ee69ae6e1512c0a04d3129fb65f5aa0efd1c1e26b57045885175aaf73681ec40b25877ba4459620abd6850536a46a5df889821e75701ffccfc36937653e5d07098ea05923b937b22d3960aea960d8a6ea6933dbf711accd796a7199c41a7361e2fa6826369fa510f9d1af79effdccf6cdae169472434fbeaed2b20d74cc98ea823cd6e8cd61f18347c0ccf0b6796fa90f2eb8b99aed6d926cc615275d31cb5a400ad2ad6c45547eb59d67cfcf1a83ae3da387a127b98c01de57f944934494f84aac8be96e06ddf8641f0e5a0bde480006624c4f41d46d6a43620799ad1a3dd89a96383af059a8bcf39e7f5ed921e831efe666b5261310b4eef8abe49d05418604b0002ad19ca7df6e3af4bc541550000cd438261c0e7dbf87bbb94cd0c349f8d8d83c7a29d31418525d7c3c8684680954771401aed74eee5675f945d5f49256d3589c34b4ad9cfc24c45d1ff558434f207cccb41a66ae3cffb5e88d8b1b4cc652a7af165078a5b6328950bdf54180f7c3f581821eb0865abd4cddce61921ffc458c37b98a6c700c7d7b2cf4a3e262bab650cadb180023b1622268e2b517d7a8ce4191333d1f8957255ea99027b1cf107948d1a708845b9387c176e44f5b0d6b07ee6c9dd9b7450de78588b418565d3c602c9e4404b61f95a400cf930da6241b7e61c124c767cef73a3155da744a0fdfb884a5942cba605646f9b7af34b300a6e562943e36f85f1526dd6b91fa8c506f5c65151ebb60e75da9ad42a4ccaa9565cac00132771781f4c245aae47241ab52c9d584948a8cb35828692793a2bf22f7936c927c768a037033dbdcb9d76e6ee95560669b2acc34b11ceae4fdd01f051170d389ed49859e505fa2f0081d68cba82019e8a967e0661c987081fd6b1d278e4f9992442c10c50fdefdc17b974651f3d72819b52b9d9844e838b34778f73e626d0b7c9044c7bc481277d7d1848f49729161fa34060a43b4a75c8d78d6b01c7accda762b4458503a4e52e2574da97609f3110bf35e5e49de031b837dfab81fa3d5006dbb99ea91bb00c6983d24abf4724fb01bb9355bae7e78036fe1e054180c0a6d8bd0877790121f9f0802071a1f88188e4dcdede9d24562e9572968e284ed7410b34df48c7a991a9b2cc9b216dbe3d32782b7bfab739b0a574f2f0fb384410a6609fe0d42abf792c13f49b6d1ec1cc21011da820efa38d369d50b491497b94406b7737f579eac4f33e0401cdb4c018cf608d26c4609cebb3fe2a9da58dad8d5fda58c769ad5dedadc171da2db44993c72458b32f0e68f11971a7e0a70c9522d8c90c9292761fd18a1521564c95be87c8f93088c952477dac11ca3c27c12cad34ab950d8304f0d8a039d28617b86c6adb05b610c8763d26daf969640d19643918d14fc20bebca1b9c35109720767e30483d7c8f2e489e5ece9f60806c5050a60e359eac1436d1cf559a0477fb1cbc5bc5c3c15d14b78e061fd6fc9ed9a50c565aebeb8edb7230ec6b2a44be89249dcd9242e81e30bc00fc541ce1cc212f375ae942e11195622187c20388fc8ca80f4392dffdc384e153c8b572ac198a168fb3471cac17be2578844105a828c0075ccd9a8df2533192693cbdd118f750508cf96dfc1ddbc48030f6f125712fbd1ee01663d5f5aa1c15a804ae579c61d5aeaec7ac9665e8f72fe3498c0b1ee7a07909628c9a36cff67880695c73319f293d0280a5d714222ea6d9864e55b11621d96e1f1084dad93525d4112748acad7f2f2bb8aec17c93cf06946c2f35cc7314354cc1e57ffe09db3f4aa82d6651b62352b2900c21f10fb05eb491ed50ca9d0a4120f274e75bc5f9fb9a81232d0d4102ab675d3793553aca102355f04ea72701fa080d02470fa83c1afb2e6f04129fef8809bea0a98f421d4ebe0d82e505bec875b243bbb6dd22b3f94231028764285f7d4af1dbbdbe3b6d648bafe14036853cb4d70b3e99e0b9fba47ab52079e7cae598a266b527d81cc06f64ec880ce9d48e7521fea650b9c106be2cf36b85f033d14b06a44e1ffa9938f3b70f6c72e79dc40f1e3e1c7c6997228df3b575282c65e0331506392b729dde8af2a83c2bcfd944d5235f10054dd26d0c7ba30cf95ba6d2c7399668d31866e9e785c798de89ed44c395e5b65469b6d055b465fe42b8bfc433f2471dc7f6f9714ba6e8fa8d4de89d45d919b66ec4a2d3aa7a2c1f7fbaa8891533d319b81b9da73dff08ae44b2be64601333858d5fef57c56a26e49e2d6f3f8d3a3ad44f7dd54573a38a5c89c9a2ded6dec4d5fbb1a092b9dc36ace39f5e6ae3f77ab13da41a34e3227917fcf5eb81833222559457e79a42f636412aaba8b8898096062ad54355b0a11e56208028dcc3e199c395bc82d8c72deb78bdb8cf005d12e9eaad5ba8079dbc89bc8b8c547ae410a4648dd594384e02f4d3ac211ade2207984bd5cda3bbe565385a755374565194408c52be9d038d7438e28159f32c9c1fd1e9ef08d5dc193bb9f99fef2bde772edae0fb6790b71c9d24bc6ddb64d0f50750f06634de9d038211b38747841672af45715c8992f0dfbe3669135fbf384009c9c9db589a9c6af13693bdcb7f02ed54535bcf26c1b3973f047ca2eade7d67e231d41c5357254fa88275003d5c27afee3a94440d35e89397fc1e836e9e6b9af9790eb656cd12d2e939c56cf8614873eb9ad4a97b10c094e711623e2fe01a53a2235437ec6f132e0d58aea3d147148c18aa5560473ed6dab666fe98adf784a2ed23aa02d1fa79006c6eb71f95470f87be182fa54a30ac0ff767dc4646fca483c6230850afbef71fb9789d6b5a30b53920974c41c407249366b72fbc9aa8ce1138c2845d90c9147fd3d22b46f8031d5b4aff87b45c14dcd9758374b00eedc5e5e29ea317f0ba7b0d30c28fe4878d6597d30b14b9d210816b9b77c8b247af441c8c6cedf41f056dd9b45e0224bebea051ffa4a8e7ba8615deb92a631c02d7bd99097754f070608d9062421eec8ff8ec9c4edd5c99519d08aee41430138e80be83abe797d912538bea8de0a93e79856ad7284c9e5702db3dc73cf4b92a35215ee8640915d0cf645d04590978ff54c088003dc940efb80e556b716fe7e41f4ba9753d68a0639848b7f71490e8dab202b5929eaca1a47be5bbc29e4889241cf59e335d013eab1988b7585af5a7ced774f90a4b8aa5321cfdea186956a51d4d713aab72871f10f0ba251cb12d1adb2853e630c40deda4fa4a932855278e593d287b71653c12db3ea470c368013be4f96d15945f4e5f7ab2de2afb27f0b7e270c96d6fe84290f91ef19d33aa7ba005500c67ad09fea05f736ac1b8f7f963c8c6b2de4af360f08dab451d92852b5d2037afa61f939c8fb33ca9e02962a07561920cd85bfabcfd21e6af2d90a36eab5b5032f94165b459393a8b089fd9ea3a2f8bdd50403bc86df9d09daf38dfb1fccfdf926ca7c39123394d9cb650bdb64156ca7b3553cd3c5ab785b6c113d63c7a8a1611125e23f075d535aec1303a2593632acee8e0707282461fd699045aad228383fc19986ebecd993838c5af73ed0599ad69314aa14971ded4f6499f11982ecb4308b4ddbeedd51417036241b3fac5677ccf97c044e9796ef393f37dd6812ed4f8820f20dd1ac6ba4352cc9e7e8abb1a4e2c1ff06694d70ebe493d1360ea8be3dbb2f245d48c521ec2ab36b0ffe87b107f4d7474f11342e413476c26a2876564203bfa1fc716b5b4813a98852257043af409054e4bdbcd55c9be641c8eab05b8ad276dca62a2900ebce1151e6785405c38c2f5b50c083ec96bbec483198ae2f6bbb65af0f340298ed32735835109149306fceb553efdcb832c953a6251d1932e16dbe852598da25c65e609e23cc06f9da90958177df39300ed2592062d3049d7c5244649056d806861352be166da84337319a720da6ab9f688c4ff54fc2b1920456e41904f52fef32145199a94e1ac4e2686896ba2b517d577dead83d7e0c2e58fe553e33677554dc118576841a7a97307a84d58ab6cc2e72899cc1530057b86fd03636683c250bff9a2b457bf72a671af4886a8963f3ef72360f02d69d53b71358d93a42786e1548eb67e6a8e3f1e8f5cbd6a455db5f51614076641d7d7603057d669acdd0e0d71e431dc130758c7266de28ca350d9ee52abd71972cd36d44bf449cf09aa53f3628e48d2886c5c1fe0e9b3afe639456f8d62a1b9598647636a48ed0fdc202e517bbca103f983ac5427ce75535608d7b60778edf3728fa44845e7e2a54051b0388dfb88f7afae4ac4288f2aae32d42f5038752a18229e07ba5d8b56546af02455354ce578dcda55486ccef354372d8e249b9d9f3ee67547ce6b574d1d9ca72304f1210e1c6d96116e39188c89f0c9fe0f5c96b739c44e2be5e63353bfbd58c5efd61aeaa11fbf93f9014129ae4ff9c664a5aca401e45981c7ee437d53fb137e7bd2a5721856f72ecf0b685eab0ba5d58 Hey, password is required here.","link":"/2021/12/14/complier-lab5/"},{"title":"ikfast-configuration","text":"​ IKFAST is a very powerful tool when a robot requires inverse kinematic solutions, so it’s necessary for us to config a customized robot ikfast plugin from scratch, which is a basic skill for a robotic engineer, I deem. 1. Configure the ikfast for flexiv robot​ As first search shows, the ikfast is provided by OpenRAVE which is a very complex planning framework. OpenRAVE requires a tricky installing process, and using not supported environment to install it will cause a lot of frustration. Luckily, there is a docker image to help us get rid of such tedious and troublesome work. I fork the repo to better save the docker image. The docker image provides Ubuntu 14.04 with OpenRAVE 0.9.0 and ROS Indigo installed, which can be used to generate the solver code once. You can browse the docker image by the following command. 1docker pull kamicode/personalrobotics:ros-openrave ​ The script in moveit_kinematics which is called auto_create_ikfast_moveit_plugin.sh will automatically build the docker environment and prepare the OpenRAVE. ​ Since we have the robot’s urdf, we can use the following command to create the ikfast plugin. 12export MYROBOT_NAME=&quot;panda&quot; &amp;rosrun moveit_kinematics auto_create_ikfast_moveit_plugin.sh --iktype Transform6D $MYROBOT_NAME.urdf &lt;planning_group_name&gt; &lt;base_link&gt; &lt;eef_link&gt; ​ In my case, the command is 1rosrun moveit_kinematics auto_create_ikfast_moveit_plugin.sh --iktype Transform6D --name flexiv &lt;somewhere&gt;/ws_moveit/src/moveit_resources/flexiv_description/robot.urdf arm base link7 ​ I specify the –name attribute, because if I use the absolute path, the auto-extracted name may not be correct. ​ The result after several minute is as follows. 12345678910111213141516171819202122Running &lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/ikfast_kinematics_plugin/scripts/create_ikfast_moveit_plugin.py &quot;flexiv&quot; &quot;arm&quot; &quot;flexiv_arm_ikfast_plugin&quot; &quot;base&quot; &quot;link7&quot; &quot;/tmp/ikfast.rn0uJk/.openrave/kinematics.f82de3cf02e1545e44ec052f9f4778ca/ikfast0x10000049.Transform6D.1_2_3_4_5_6_f0.cpp&quot;Creating IKFastKinematicsPlugin with parameters: robot_name: flexiv base_link_name: base eef_link_name: link7 planning_group_name: arm ikfast_plugin_pkg: flexiv_arm_ikfast_plugin ikfast_output_path: /tmp/ikfast.rn0uJk/.openrave/kinematics.f82de3cf02e1545e44ec052f9f4778ca/ikfast0x10000049.Transform6D.1_2_3_4_5_6_f0.cpp search_mode: OPTIMIZE_MAX_JOINT srdf_filename: flexiv.srdf robot_name_in_srdf: flexiv moveit_config_pkg: flexiv_moveit_configFound source code generated by IKFast version 73Failed to find package: flexiv_arm_ikfast_plugin. Will create it in &lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin.Created ikfast header file at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/include/ikfast.h'Created ikfast plugin file at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/src/flexiv_arm_ikfast_moveit_plugin.cpp'Created plugin definition at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/flexiv_arm_moveit_ikfast_plugin_description.xml'Created cmake file at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/CMakeLists.txt'Wrote package.xml at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/package.xml'Created update plugin script at '&lt;somewhere&gt;/ws_moveit/src/moveit/moveit_kinematics/flexiv_arm_ikfast_plugin/update_ikfast_plugin.sh'Modified kinematics.yaml at '&lt;somewhere&gt;/ws_moveit/src/flexiv_moveit_config/config/kinematics.yaml' ​ Notice the upper script has modified the kinematics.yaml in flexiv_moveit_config, which means the robot will use the ikfast to calculate ik. 1234arm: kinematics_solver: flexiv_arm/IKFastKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.005 ​ But if we using the following command to visualize the flexiv robot in RViz, we can find an error which means that the moveit can not load the flexiv-ikfast plugin. 1roslaunch flexiv_moveit_config demo.launch ​ The error is 12[ERROR] [1636036724.761299732]: The kinematics plugin (arm) failed to load. Error: According to the loaded plugin descriptions the class flexiv_arm/IKFastKinematicsPlugin with base class type kinematics::KinematicsBase does not exist. Declared types are cached_ik_kinematics_plugin/CachedKDLKinematicsPlugin cached_ik_kinematics_plugin/CachedSrvKinematicsPlugin kdl_kinematics_plugin/KDLKinematicsPlugin lma_kinematics_plugin/LMAKinematicsPlugin prbt_manipulator/IKFastKinematicsPlugin srv_kinematics_plugin/SrvKinematicsPlugin[ERROR] [1636036724.761371349]: Kinematics solver could not be instantiated for joint group arm. ​ It tells us that MoveIt can not find the flexiv-ikfast plugin. So we goto the /ws_moveit/src/moveit/moveit_kinematics to find out why. ​ There is flexiv_arm_ikfast_plugin indeed in the directory, but it seems not be complied. I try to add some lines to the CMakeList.txt in moveit_kinematics directory but failed in compiling. But I find if I copy the flexiv_arm…._plugin out as a single package to compile. Rviz works without informing “plugin not found”. 2. Validate the output ikfast file works​ Because RViz will pick available ik solver if it can not find configured ikfast plugin, even if the error message has been eliminated, we can not make sure that the RViz planing do use the ikfast. We need to find an another way. ​ An article proposes another way for us. That is, use the ikfastdemo.cpp to do the validation. We can simply put the ikfastdemo.cpp in the same directory with our ikfast cpp, and make ikfastdemo.cpp inlcude it. ​ So we add two lines to ikfastdemo.cpp. 12#define IK_VERSION 73#include &quot;flexiv_arm_ikfast_solver.cpp&quot; ​ And compile it. 1g++ ikfastdemo.cpp -lstdc++ -llapack -o compute -lrt ​ The usage is as follows. 123456789101112131415161718Usage: ./compute fk j0 j1 ... j6 Returns the forward kinematic solution given the joint angles (in radians). ./compute ik t0 t1 t2 qw qi qj qk free0 ... Returns the ik solutions given the transformation of the end effector specified by a 3x1 translation (tX), and a 1x4 quaternion (w + i + j + k). There are 1 free parameters that have to be specified. ./compute ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ... Returns the ik solutions given the transformation of the end effector specified by a 3x3 rotation R (rXX), and a 3x1 translation (tX). There are 1 free parameters that have to be specified. ./compute iktiming For fixed number of iterations, generates random joint angles, then calculates fk, calculates ik, measures average time taken. ./compute iktiming2 For fixed number of iterations, with one set of joint variables, this finds the ik solutions and measures the average time taken. 2.1 Painful debug timeI use the following command to calculate a forward kinematic solution. 12345678910111213141516./compute fk 1.57 1.57 1.57 1.57 1.57 1.57 1.57Found fk solution for end frame: Translation: x: -0.484689 y: 0.475605 z: 0.400080 Rotation 0.001591 0.001596 -0.999997 Matrix: 0.999996 0.002387 0.001595 0.002390 -0.999996 -0.001592 Euler angles: Yaw: -1.572388 (1st: rotation around vertical blue Z-axis in ROS Rviz) Pitch: 1.568409 Roll: 0.001595 Quaternion: -0.500596 0.500199 0.500597 -0.498606 -0.500596 + 0.500199i + 0.500597j - 0.498606k (alternate convention) ​ To visualize the solution in the RViz, I set the flexiv robot at the same configuration, and add a box indicating the calculation of the ikfast forward kinematics. ​ It seems the base joint need to rotate 180 degree to fit the result of ikfast fk, which is very weird. I spend a lot of time debugging on the problem. What remains unknown is that the RViz motion planning plugin still works well though the ikfast is not giving the correct answer. So it may not use ikfast or experience some downgrade mode because the failure of finding a solution by ikfast plugin. ​ By chance, I find that the yaw angle of the first fixed joint is strange. 123456&lt;!-- ============ joint 0 =============== --&gt;&lt;joint name=&quot;joint0&quot; type=&quot;fixed&quot;&gt; &lt;origin rpy=&quot;0 0 -3.1415927&quot; xyz=&quot;0 0 0.0&quot;/&gt; &lt;parent link=&quot;world&quot;/&gt; &lt;child link=&quot;base&quot;/&gt;&lt;/joint&gt; ​ It is exactly 180 degree, which fits our guess. So I change the value of that yaw angle to zero. And everything works. But what cause the difference? Remember we do NOT set the virtual joint when configuring the flexiv in MoveIt Setup Assistant because we find the fixed joint in URDF ? If we did that as the tutorial, it will add following lines into our robot.srdf. 12&lt;!--VIRTUAL JOINT: Purpose: this element defines a virtual joint between a robot link and an external frame of reference (considered fixed with respect to the robot)--&gt;&lt;virtual_joint child_link=&quot;panda_link0&quot; name=&quot;virtual_joint&quot; parent_frame=&quot;world&quot; type=&quot;floating&quot;/&gt; ​ So BEAR IN MIND, IT IS A CONVENTION THAT THE VIRTUAL JOINT SHOULD BE WITH RPY=”0 0 0”!!! 2.2 Result ​ Finally, I find both the joint and the box overlap however I change the joint position, which means the forward kinematics of ikfast calculate the correct result ! 3. Add ikfast into pybullet-planning module​ Let’s first have a glance on the directory structure of the pybullet-planning/pybullet_tools/ikfast ​ We need to add flexiv directory which includes The ik.py defines some basic information of our new robot. 1234567from ..utils import IKFastInfofrom ..ikfast import * # For legacy purposesFLEXIV_URDF = &quot;models/flexiv_description/flexiv.urdf&quot;FLEXIV_INFO = IKFastInfo(module_name='flexiv.ikfast_flexiv', base_link='base', ee_link='link7', free_joints=['joint1']) The setup.py helps us to compile a pybind11 module, which a shared library .so file. The code is mainly modified from the existed ikfast robot directory. 1234567891011121314151617181920#!/usr/bin/env pythonfrom __future__ import print_functionimport sysimport ossys.path.append(os.path.join(os.pardir, os.pardir, os.pardir))from pybullet_tools.ikfast.compile import compile_ikfast# Build C++ extension by running: 'python setup.py'# see: https://docs.python.org/3/extending/building.htmldef main(): # lib name template: 'ikfast_&lt;robot name&gt;' sys.argv[:] = sys.argv[:1] + ['build'] robot_name = 'flexiv' compile_ikfast(module_name='ikfast_{}'.format(robot_name), cpp_filename='ikfast_{}.cpp'.format(robot_name))if __name__ == '__main__': main() ​ In the original ikfast_flexiv.cpp, to enable the pybind11, we have to add a lot of functions and include “Python.h”. Luckily the author of pybullet-planning has written it for us, so we only to add these lines at the end. ​ Then we simply use the command 1234$python setup.py build......ikfast module ikfast_flexiv imported successful ​ We can modify the test codes in pybullet-planning examples to check whether our flexiv robot can use ikfast to calculate now. ​ The result shows we did it !","link":"/2021/11/06/ikfast-configuration/"},{"title":"MoveIt Configuration","text":"在配置ROS-noetic MoveIt的时候，不可避免地遇到了一些问题。在此记录一下。 官网配置教程地址： https://ros-planning.github.io/moveit_tutorials/doc/getting_started/getting_started.html Catkin是ROS官方的构建编译系统，是原先的ROS编译构建系统rosbuild的继承者，它组合了cmake宏和python脚本来在基本的cmake工作流之上提供一些额外的功能。Catkin设计得比rosbuild更加便捷，允许更好地分配package，支持更好的交叉编译以及更好的便捷性。Catkin的工作流和cmake的工作流很像，但是还添加了自动find package的基础结构，并且在同时构建多个相互依赖的项目。 catkin编译的工作流程如下： 首先在工作空间catkin_ws/src/下递归的查找其中每一个ROS的package。package中会有package.xml和CMakeLists.txt文件，Catkin(CMake)编译系统依据CMakeLists.txt文件,从而生成makefiles(放在catkin_ws/build/)。 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在catkin_ws/devel)也就是说，Catkin就是将cmake与make指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是： 1.操作更加简单 2.一次配置，多次使用 3.跨依赖项目编译 使用catkin_make进行编译 123$ cd ~/catkin_ws #回到工作空间,catkin_make必须在工作空间下执行$ catkin_make #开始编译$ source ~/catkin_ws/devel/setup.bash #刷新坏境 编译完成后，如果有新的目标文件产生（原来没有），那么一般紧跟着要source刷新环境，使得系统能够找到刚才编译生成的ROS可执行文件。这个细节比较容易遗漏，致使后面出现可执行文件无法打开等错误。 第一次catkin build的时候，我们遇到如下错误： 根据回答，我们修改原先的catkin_build指令，修改为catkin build -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.7m。换句话说，ROS的catkin默认的是用python2.7去编译的，哪怕我们安装了python3-empy它依然报错。告诉它使用python3后这个报错就解决了。 第二个问题是tinyxml.h找不到tinystr.h文件。我们找到对应位置后在源码中添加TIXML_USE_STL即可解决这个问题，使用标准的STL库来代替tinystr.h。 第三处build的问题是 它提示我们找不到pyconfig.h，根据这篇博客的提示，我先使用sudo find / -name pyconfig.h，发现在路径/usr/include/python3.8下存在pyconfig.h，原来是解决问题1的时候复制的路径/usr/include/python3.7m根本不存在，把命令改为 12catkin build -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.8source devel/setup.bash 即可正常编译成功。 接下来我们使用命令 1roslaunch panda_moveit_config demo.launch rviz_tutorial:=true 这里会再次遇到一个问题，根据此回答即可解决。 自此我们可以正常运行并且看到Rviz界面，添加MotionPlanning后就可以在RViz界面中见到我们的panda机器人。 我们首先需要知道4种重叠的可视化： robot在planning environment中的configuration（各个关节的当前角度）。 robot的plan出来的路径 绿色：robot motion planning的开始状态 橙色：robot motion planning的结束状态 这些展示的状态可以在上面的motionplanning的下拉框中勾选。Planning scene在show robot visual-&gt;Scene Robot中；planning path在show robot visual-&gt;Planned Path中；开始状态在Query Start State-&gt;Planning Request中；结束状态的设置在Query Start State-&gt;Planning Request。 我们可以拖动各个关节的orientation来设置开始状态和结束状态。然后点击plan可以查看整个的运动轨迹。我们勾选use collision-aware IK就可以使得求解器尝试找到一个collision-free的轨迹；如果没有勾选的话，求解器会允许在过程中碰到collision。不过在可视化的时候，存在碰撞的link无论我们有没有勾选use collision-aware IK，都会被标识成红色。 在MotionPlanning的joint窗口下，我们可以拖动nullspace exploration，可以看到在末端执行器的位姿不变的情况下，其他机械臂的configuration是可以变化的（满足连续关系）。 现在我们可以开始使用panda机器人在moveit rviz插件中进行运动规划。步骤如下： 把start state设置到期望的位置 把goal state设置到期望的位置 确保这两个state都没有自己和自己碰撞 确保planned path是可见的 按下plan键。 我们在Planning窗口中可以选择不同的start和goal states，eg：当前的状态，之前的状态（之前的planning attempt的start state），一个随机采样的configuration，一个有名字的在srdf中定义的state。 我们也可以查看轨迹路径点，只需要在导航栏中打开panels-&gt;motionplanning-slider，即可看到对应的路径点并拖动。 如果我们勾选use cartesian path的话，robot会尝试直线地移动end effector。 [1]Catkin工作原理 https://blog.csdn.net/qq_33876441/article/details/102958248 [2]Catkin conceptual http://wiki.ros.org/catkin/conceptual_overview [3]https://blog.csdn.net/num8owl/article/details/108689843","link":"/2021/10/20/moveit-configuration/"},{"title":"mmdection_hammer_segmentation","text":"The first time for me to construct a custom dataset and apply it in the mmdection. The whole pipeline is as follows: I. Collect and prepare the raw dataset. II. Convert the raw dataset into COCO style. III. Add and movify the mask-rcnn configuration in mmdection API to fit our requirement. IV. Train the model by mmdection. V. Evaluate and visualize the test dataset. VI. Modify the result into mask image so that we can insert it smoothly in our pipeline. Because of the fact that the project is still ongoing, the part I and part VI will NOT be described detailedly. 1.The dataset As shown above, it’s a sample from my created dataset which contains a rgb image and corresponding mask. The foreground is a tool(the hammer), and the background contains other unrelated things. At the very beginning when there was no relationship to how to training, it is of top priority to create enough data and split them into train, validate and test dataset. We collected 4535 imgs, 464 imgs and 454 imgs for training, validating and evaluating. 2. The format of COCOAs said by a famous blog, we use COCO to reconstruct our data is not because it is the best format, but it is the most widely used and accepted format. So we need to arrange our dataset in that format. To our relief, there are a lot of tools to help us automatically conduct such procedure, for example, pycococreator. What we need to do is only to set the related INFO, LICENSES, CATEGORIES and corresponding directory. 1234567891011121314151617181920212223242526272829303132333435363738INFO = { &quot;description&quot;: &quot;Hammer Segmentation Dataset&quot;, &quot;url&quot;: &quot;https://github.com/Kami-code&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;year&quot;: 2022, &quot;contributor&quot;: &quot;Kami-code&quot;, &quot;date_created&quot;: datetime.datetime.utcnow().isoformat(' ')}LICENSES = [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Attribution-NonCommercial-ShareAlike License&quot;, &quot;url&quot;: &quot;http://creativecommons.org/licenses/by-nc-sa/2.0/&quot; }]CATEGORIES = [ { 'id': 1, 'name': 'hammer', 'supercategory': 'none', },]...def main(): ROOT_DIR = 'hammer_' + MODE IMAGE_DIR = os.path.join(ROOT_DIR, &quot;rgb&quot;) ANNOTATION_DIR = os.path.join(ROOT_DIR, &quot;mask&quot;) coco_output = { &quot;info&quot;: INFO, &quot;licenses&quot;: LICENSES, &quot;categories&quot;: CATEGORIES, &quot;images&quot;: [], &quot;annotations&quot;: [] }... The structure is from the blog. You can refer to it to create your custom dataset. What I want to mention is if we have a lot of mask of different objects on a single image(though not in our current settings), the annotation_id should start from 0 and increase for each mask, while the meaning of image_id is easily understood. By the way, it seems no need to make annotation_id the same as “id” in CATEGORIES, so making it start from zero is necessary. After running the script of pycococreator, we get a single json file named “instance_train2022.json”. We can use the visualizer script provided in that repo to visualize to check whether we successfully get a COCO json file. COCO will contain the information which provided in the mask.png file using contour algorithm.(Finally, they will be stored in polygons format.) Since now, we have successfully got our first COCO dataset! 3. MMDectionMMDetection is an open source object detection toolbox based on PyTorch. It is a part of the OpenMMLab project. It provides a abstraction on the PyTorch which enables me train my network without writing any code. Frankly speaking, I will not use it if I have enough time to dig deep in mask-rcnn, cause it makes me tightly rely on the API, which do no good for my career. For now, given limited time, I have to use it. To use it, I mainly refer to the proceduce in this zhihu blog. But it also contains some frustrating bug, which I will explain below. This is the files need to add and modify if we want to add a new dataset to train by mask_rcnn. (marked in green means the newly-added file and marked in brown means the file needed to be modified) Let’s find how exactly these files works. mmdection/configs/mask_rcnn/my_mask_rcnn.py 123456_base_ = [ '../_base_/models/my_mask_rcnn_r50_fpn.py', '../common/my_coco_instance.py','../_base_/schedules/schedule_2x.py' ,'../_base_/default_runtime.py',] The file just links all the files we added. Next, we should define our own dataset structure, since we’ve got the dataset in COCO format. We can replicate the coco.py and change a little to get our “keto_coco.py”. mmdection/mmdet/datasets/coco.py 123456789101112131415161718@DATASETS.register_module()class CocoDataset(CustomDataset): CLASSES = ('person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush') ... mmdection/mmdet/datasets/keto_coco.py 12345@DATASETS.register_module()class KpCocoDataset(CustomDataset): CLASSES = ['hammer',] ... As we can see, what we do is just set the CLASSES variable into a list only containing one class hammer. The reason that we change the tuple to list seems to be a version-related problem that the low-level function will misleadingly parse the wrong type. mmdection/mmdet/datasets/init.py 12345678910__all__ = [ 'CustomDataset', 'XMLDataset', 'CocoDataset', 'DeepFashionDataset', 'VOCDataset', 'CityscapesDataset', 'LVISDataset', 'LVISV05Dataset', 'LVISV1Dataset', 'GroupSampler', 'DistributedGroupSampler', 'DistributedSampler', 'build_dataloader', 'ConcatDataset', 'RepeatDataset', 'ClassBalancedDataset', 'WIDERFaceDataset', 'DATASETS', 'PIPELINES', 'build_dataset', 'replace_ImageToTensor', 'get_loading_pipeline', 'NumClassCheckHook', 'CocoPanopticDataset', 'MultiImageMixDataset', 'KpCocoDataset'] Since we defined our KpCocoDataset, to make it register into the dataset collection, we need to add the structure name into its init.py and recomplie the module. In class_names.py, we should also add a simple function to get the classes of our defined dataset. mmdection/mmdet/core/evaluation/class_name.py 1234...def kp_coco_classes(): return ['hammer']... Also, a change in init.py is necessary. But there is no explicit call of this function, I GUESS the function may not be called or is called by its name in some format. The my_mask_rcnn_r50_fpn.py is replicated from the mask_rcnn_r50_fpn.py. We just change the class_num parameter 80 to 1. In my_coco_instance.py, we defined the path of the three COCO json files, and train and test pipeline. mmdection/configs/common/my_coco_instance.py 123456789101112131415161718192021222324...data = dict( samples_per_gpu=2, workers_per_gpu=2, train=dict( type='RepeatDataset', times=4, dataset=dict( type=dataset_type, ann_file=data_root + 'annotations/instances_train2022.json', img_prefix=data_root + 'train2022/', pipeline=train_pipeline)), val=dict( type=dataset_type, ann_file=data_root + 'annotations/instances_validate2022.json', img_prefix=data_root + 'validate2022/', pipeline=test_pipeline), test=dict( type=dataset_type, ann_file=data_root + 'annotations/instances_test2022.json', img_prefix=data_root + 'test2022/', pipeline=test_pipeline),)... And we will train the data on a single GPU with 2 samples_per_gpu, so we should downsize the learning rate defined in schedule_2x.py 8 times, because it’s default value is assuming the training is on 8 GPUs with 2 samples_per_gpu. 4. Train our modelWe can use the following command line to start training process. Though I have spent much time in debugging in the process. If we correctly config the mentioned files, it will finally works. 1python tools/train.py configs/mask_rcnn/my_mask_rcnn.py When training, we can read the logs to make sure we are on the right track. 12021-10-27 15:16:22,077 - mmdet - INFO - Epoch [1][2400/9070] lr: 2.500e-03, eta: 17:30:32, time: 0.288, data_time: 0.010, memory: 7875, loss_rpn_cls: 0.0216, loss_rpn_bbox: 0.0081, loss_cls: 0.0925, acc: 97.2070, loss_bbox: 0.1120, loss_mask: 0.1732, loss: 0.4074 How are the batches each epoch 9070 calculated? Recall that we set the training set to be repeat dataset 4, which means the total training dataset is 4535 * 4 = 18140. And we configure the training process on a single with samples_per_gpu = 2. So we get batch_size = 18140 / 2 = 9070. 1234567891011121314151617181920212223242021-10-27 22:03:28,363 - mmdet - INFO - Evaluating segm...Loading and preparing results...DONE (t=0.04s)creating index...index created!Running per image evaluation...Evaluate annotation type *segm*DONE (t=0.46s).Accumulating evaluation results...DONE (t=0.05s). Average Precision (AP) @[ IoU=0.50:0.95 | area= all | maxDets=100 ] = 0.367 Average Precision (AP) @[ IoU=0.50 | area= all | maxDets=1000 ] = 0.416 Average Precision (AP) @[ IoU=0.75 | area= all | maxDets=1000 ] = 0.415 Average Precision (AP) @[ IoU=0.50:0.95 | area= small | maxDets=1000 ] = -1.000 Average Precision (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=1000 ] = 0.365 Average Precision (AP) @[ IoU=0.50:0.95 | area= large | maxDets=1000 ] = 0.369 Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets=100 ] = 0.373 Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets=300 ] = 0.373 Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets=1000 ] = 0.373 Average Recall (AR) @[ IoU=0.50:0.95 | area= small | maxDets=1000 ] = -1.000 Average Recall (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=1000 ] = 0.369 Average Recall (AR) @[ IoU=0.50:0.95 | area= large | maxDets=1000 ] = 0.3752021-10-27 22:03:28,939 - mmdet - INFO - Exp name: my_mask_rcnn.py2021-10-27 22:03:28,939 - mmdet - INFO - Epoch(val) [9][464] bbox_mAP: 0.3800, bbox_mAP_50: 0.4210, bbox_mAP_75: 0.4090, bbox_mAP_s: -1.0000, bbox_mAP_m: 0.3880, bbox_mAP_l: 0.3760, bbox_mAP_copypaste: 0.380 0.421 0.409 -1.000 0.388 0.376, segm_mAP: 0.3670, segm_mAP_50: 0.4160, segm_mAP_75: 0.4150, segm_mAP_s: -1.0000, segm_mAP_m: 0.3650, segm_mAP_l: 0.3690, segm_mAP_copypaste: 0.367 0.416 0.415 -1.000 0.365 0.369 Some results are as shown in the sheet. In this article, we don’t detailedly explain what each statistic means. 5. Evaluate and visualize our modelWe can run the following script to visualize our model. 12345678910111213from mmdet.apis import init_detector, inference_detector, show_result_pyplotif __name__ == '__main__': config_file = 'mmdetection/configs/mask_rcnn/my_mask_rcnn.py' # url: https://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth checkpoint_file = 'mmdetection/work_dirs/my_mask_rcnn/latest.pth' device = 'cpu' # init a detector model = init_detector(config_file, checkpoint_file, device=device) # inference the demo image img = '../tool_seg_data/neee/rgb/1906.jpeg' result = inference_detector(model, img) show_result_pyplot(model, img, result, score_thr=0.3) Thank God we finally successfully train the segmentation network.","link":"/2021/10/29/mmdection-hammer-segmentation/"},{"title":"moveit_planning_scene_tutorial","text":"moveit_planning_scene_tutorial Part1 Add primitive shape into planning scene​ The planning scene is a very useful tool when we want to create a collision-free trajectory for our robot. The first thing is that whatever our target is, the custom mesh object need to be added into the scene for realistic planning. We first introduce the tutorial on the moveit website. 12345678910111213141516171819202122232425262728293031323334353637383940414243......// Now let's define a collision object ROS message for the robot to avoid.moveit_msgs::CollisionObject collision_object;collision_object.header.frame_id = move_group_interface.getPlanningFrame();// The id of the object is used to identify it.collision_object.id = &quot;box1&quot;;// Define a box to add to the world.shape_msgs::SolidPrimitive primitive;primitive.type = primitive.BOX;primitive.dimensions.resize(3);primitive.dimensions[primitive.BOX_X] = 0.1;primitive.dimensions[primitive.BOX_Y] = 1.5;primitive.dimensions[primitive.BOX_Z] = 0.5;// Define a pose for the box (specified relative to frame_id)geometry_msgs::Pose box_pose;box_pose.orientation.w = 1.0;box_pose.position.x = 0.5;box_pose.position.y = 0.0;box_pose.position.z = 0.25;collision_object.primitives.push_back(primitive);collision_object.primitive_poses.push_back(box_pose);collision_object.operation = collision_object.ADD;std::vector&lt;moveit_msgs::CollisionObject&gt; collision_objects;collision_objects.push_back(collision_object);// Now, let's add the collision object into the world// (using a vector that could contain additional objects)ROS_INFO_NAMED(&quot;tutorial&quot;, &quot;Add an object into the world&quot;);planning_scene_interface.addCollisionObjects(collision_objects);// Show text in RViz of status and wait for MoveGroup to receive and process the collision object messagevisual_tools.publishText(text_pose, &quot;Add object&quot;, rvt::WHITE, rvt::XLARGE);visual_tools.trigger();visual_tools.prompt(&quot;Press 'next' in the RvizVisualToolsGui window to once the collision object appears in RViz&quot;);// Now when we plan a trajectory it will avoid the obstaclesuccess = (move_group_interface.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);...... ​ We also can attach objects to the robot, so that it moves with the robot geometry. This simulates picking up the object for the purpose of manipulating it. The motion planning should avoid collisions between the two objects as well. 123456789101112131415161718192021222324252627282930313233343536373839moveit_msgs::CollisionObject object_to_attach;object_to_attach.id = &quot;cylinder1&quot;;shape_msgs::SolidPrimitive cylinder_primitive;cylinder_primitive.type = primitive.CYLINDER;cylinder_primitive.dimensions.resize(2);cylinder_primitive.dimensions[primitive.CYLINDER_HEIGHT] = 0.20;cylinder_primitive.dimensions[primitive.CYLINDER_RADIUS] = 0.04;// We define the frame/pose for this cylinder so that it appears in the gripperobject_to_attach.header.frame_id = move_group_interface.getEndEffectorLink();geometry_msgs::Pose grab_pose;grab_pose.orientation.w = 1.0;grab_pose.position.z = 0.2;// First, we add the object to the world (without using a vector)object_to_attach.primitives.push_back(cylinder_primitive);object_to_attach.primitive_poses.push_back(grab_pose);object_to_attach.operation = object_to_attach.ADD;planning_scene_interface.applyCollisionObject(object_to_attach);// Then, we &quot;attach&quot; the object to the robot. It uses the frame_id to determine which robot link it is attached to.// You could also use applyAttachedCollisionObject to attach an object to the robot directly.ROS_INFO_NAMED(&quot;tutorial&quot;, &quot;Attach the object to the robot&quot;);move_group_interface.attachObject(object_to_attach.id, &quot;panda_hand&quot;);visual_tools.publishText(text_pose, &quot;Object attached to robot&quot;, rvt::WHITE, rvt::XLARGE);visual_tools.trigger();/* Wait for MoveGroup to receive and process the attached collision object message */visual_tools.prompt(&quot;Press 'next' in the RvizVisualToolsGui window once the new object is attached to the robot&quot;);// Replan, but now with the object in hand.move_group_interface.setStartStateToCurrentState();success = (move_group_interface.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);ROS_INFO_NAMED(&quot;tutorial&quot;, &quot;Visualizing plan 7 (move around cuboid with cylinder) %s&quot;, success ? &quot;&quot; : &quot;FAILED&quot;);visual_tools.publishTrajectoryLine(my_plan.trajectory_, joint_model_group);visual_tools.trigger();visual_tools.prompt(&quot;Press 'next' in the RvizVisualToolsGui window once the plan is complete&quot;); ​ Now we can create the collision-free trajectory with our attached object. Since, we can not replace everything with basic primitive shape in this tutorial, because such a simplification will cause some difference and mismatch in our digital twin and the real environment setting. Part2 Add custom object into planning scene​ This tutorial demonstrates the way to add the custom object into the planning scene. To be more specific, we need a .stl or .dae model file. This difference between .obj, .stl and .dae is described in blog1 and blog2, from which we can know the interconversion between .obj and .stl file can be easily conducted. 12345678910111213141516171819202122232425262728293031323334//Vector to scale 3D file units (to convert from mm to meters for example)Vector3d vectorScale(0.001, 0.001, 0.001);// Define a collision object ROS message.moveit_msgs::CollisionObject collision_object;// The id of the object is used to identify it.collision_object.id = &quot;custom_object&quot;;//Path where the .dae or .stl object is locatedshapes::Mesh* m = shapes::createMeshFromResource(&quot;&lt;YOUR_OBJECT_PATH&gt;&quot;, vectorScale); ROS_INFO(&quot;Your mesh was loaded&quot;);shape_msgs::Mesh mesh;shapes::ShapeMsg mesh_msg; shapes::constructMsgFromShape(m, mesh_msg);mesh = boost::get&lt;shape_msgs::Mesh&gt;(mesh_msg);//Define a pose for your mesh (specified relative to frame_id)geometry_msgs::Pose obj_pose;obj_pose.position.x = 0.1;obj_pose.position.y = 0.1;obj_pose.position.z = 1.0;// Add the mesh to the Collision object message collision_object.meshes.push_back(mesh);collision_object.mesh_poses.push_back(obj_pose);collision_object.operation = geometry_msgs::Pose::ADD;// Create vector of collision objects to add std::vector&lt;moveit_msgs::CollisionObject&gt; collision_objects;collision_objects.push_back(collision_object);// Add the collision object into the worldmoveit::planning_interface::MoveGroupInterface move_group(&lt;YOUR_PLANNING_GROUP&gt;);planning_scene_interface.addCollisionObjects(collision_objects); ​ Adding static meshes in the Rviz will be omitted because we want the pipeline to be automatic. ​ to be continued","link":"/2021/12/08/moveit-planning-scene-tutorial/"},{"title":"openGL和openCV中的摄像机参数的转化","text":"本文章的主题为研究openGL和openCV中的摄像机参数的转化。 首先要搞清楚，坐标旋转和坐标系旋转的概念。 坐标旋转（点的运动） 如上图，二维坐标系中的绕原点逆时针旋转度，则得到的B点满足： 把上式写成矩阵乘法的形式： 这是点的运动，坐标系（参照系）并没有发生变化 坐标系旋转（基变换） 如上图，把原先的xy基逆时针旋转度到st基，p在xy基下的坐标为，p在st基下的坐标为，求变换关系。 我们有 即 2是坐标系的旋转，点是不动的，得到的是不动的点在变化了的坐标系下的表示 点旋转β相当于坐标系旋转了-β。所以可以直接在1的基础上，把角度反转，就成了坐标系的旋转。 基变换和坐标变换平面解析几何中的直角坐标系有时候需要坐旋转，这实际上是坐标向量绕原点坐旋转，设坐标轴逆时针旋转的角度为，那么不难有，新坐标向量和原坐标向量之间的关系为： OpenCV中的内参矩阵K（计算机视觉——算法和应用P41） 有几种方式来描述上三角矩阵K，一种是 上式使用相互独立的参数来描述x和y维度的焦距和，s项刻画任何可能的传感器轴间的倾斜，这由传感器的安装没有与光轴垂直所引起，而是以像素坐标表达的光心。 在实践中，通过设置和s=0，在很多应用中会使用如下更简单的形式： 通常情况下，通过将原点大致设置在图像的中心，即，其中W和H是图像的高和宽（用像素表示，如600*480），就可以得到仅含一个未知量焦距f的完全可用的摄像机模型。注意上式中的焦距都是以像素为单位表示的，要与现实相机中的毫米焦距等区分开来。 要转化到现实中的距离，我们首先需要知道图像的现实宽度，如，然后我们可以通过公式：，这里的就是视场角，也就是FOV，下图就展示了一个的情况。 为了更好地理解OpenGL中的透视投影，我们先来讨论函数glFrustum。根据OpenGL的官方文档，“glFrustum描述了一个透视矩阵，提供了一个透视投影。”这句话没错，但是只说出了一半实情。事实上，glFrustum做了两件事情，首先它进行透视投影，然后它把结果转换到归一化设备坐标系(NDC)上。前者是投影几何中的常规操作，但是后者是OpenGL中特有的实现细节。 为了讲明白这件事情，我们需要把投影矩阵（Projection Matrix）分成两部分，也就是透视矩阵(Prespective Matrix)和NDC矩阵。 我们的相机内参矩阵可以描述透视投影，所以它是求解出Perspective Matrix的关键。而对于NDC矩阵，我们会使用OpenGL的glOrtho。 第一步：投影变换 我们的3x3内参矩阵K为了能在OpenGL中使用需要两个小的变更，一个是为了正确的裁剪，位置3,3的元素必须为-1，因为OpenGL的摄像机是从原点向z的负半轴看的，所以如果位置3,3的元素为正，摄像机前方的顶点在投影后将具有负的w坐标。原则上，这是可以的，但是由于 OpenGL 执行裁剪的方式，所有这些点都会被裁剪。 所以我们现在有了 对于第二个更改，我们需要保护失去的Z轴的深度信息，所以我们会在内参矩阵的基础上添加一行和一列，即： ，其中 新的第三行保持了Z值的顺序的同时，把-near和-far映射到它们自己（在归一化了w后）。这个结果就是在裁剪平面之间的点依旧在乘上了Perspective Matrix后依旧保持在裁剪平面之间。 第二步：变换到NDC NDC矩阵可以通过glOrtho函数提供。Perspective Matrix把一个视锥空间转化为了一个长方体空间，而glOrtho把长方体空间转化为归一化设备空间。 调用glOrtho需要六个参数left,right,bottom,top,near,far ，其中 调用它的时候，far和near就和前述的一样。而top,bottom,left,right的裁剪平面的选取对应原图像的维度和标定时的坐标规范。 举个例子，如果你的摄像机用WxH的左上角为零点的图像标定了，那么就该使用left = 0, right = W, bottom = H, top = 0，注意到H作为了bottom参数而0作为了top参数，这意味着y轴正半轴是向下的规范。 如果标定时使用的是y轴向上的坐标系，并且原点在图像中心的话，那么就是left = -W/2, right = W/2, bottom = -H/2, top = H/2. 注意到其实glOrtho的参数和透视矩阵有很大的关系，比如说把视景体(viewing volume)向左平移X等价于把主轴向右平移X。而让翻倍就等于让left和right参数减半。很明显，用这两个矩阵来描述这个投影是冗余的，但是分别去考察这两个矩阵允许我们分离相机几何学和图像几何学。 根据文献 https://stackoverflow.com/questions/60430958/understanding-the-view-and-projection-matrix-from-pybullet 在pybullet中， 内参矩阵K为： 和是光心，通常是图像中心。不过有以下不同， \\1. 维度，pybullet保持了第三行和第四列来保持深度信息，这和之前提到的OpenGL相机相同。 \\2. 第四行第三列的元素不是1而是-1 \\3. Pybullet中s=0 \\4. Pybullet中 首先，pybullet使用OpenGL，所以它使用的是列优先的顺序，所以从pybullet中读到的真正的projection matrix应当转置，或者使用numpyarray的order=’F’。 其次，把FOV转化为f的方程如下： 和 因此，pybullet把焦距乘以了2/h，这是因为Pybullet使用归一化设备坐标系（也就是对x除以图像宽度，来归一化到01，再乘以2到02，所以如果我们的光心在图像中间x=1的位置时，那么裁剪平面就归一化到了-1~1）。因此，pybullet的焦距是使用NDC下的正确的焦距长度。 在内参矩阵K中，k和l是mm/px的比例，在使用pybullet时，我们可以认为k=l=1 mm/px，换句话说，在pybullet形式的内参矩阵中，和是以像素为单位的，而整个矩阵的每个元素都是以mm为单位的。 考虑到以上的所有条件，在pybullet中，内参矩阵为： ，其中 把h=1000和FOV=90代入， def computeProjectionMatrixFOV(*args, **kwargs): # real signature unknown “”” Compute a camera projection matrix from fov, aspect ratio, near, far values “”” pass def computeViewMatrix(*args, **kwargs): # real signature unknown “”” Compute a camera viewmatrix from camera eye, target position and up vector “”” pass http://ksimek.github.io/2013/06/03/calibrated_cameras_in_opengl/ https://amytabb.com/ts/2019_06_28/#conversion-corner-1 http://www.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche0092.html https://zhuanlan.zhihu.com/p/339199471","link":"/2021/10/15/opencv-opengl-camera-conversion/"},{"title":"pybind11初探","text":"最近项目过程中经常遇到底层为C++代码的情况，作为一个契机，详尽地研究一下pybind11。 虽然无关紧要，但是很在意的问题是11这个数字是哪来的，因为pybind11的介绍是 Seamless operability between C++11 and Python，据称其主要内核代码使用了C++11的语言特性，如匿名函数、元组等。 如上图所示，这是符合pybind11编程要求的c++代码。 图 1 https://zhuanlan.zhihu.com/p/92120645 根据pybind11官网教程，可以使用如下代码进行编译： c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 –includes) example.cpp -o example$(python3-config –extension-suffix) -Wall 这个编译选项会强制输出所有警告，用于调试。 -o output_filename 确定输出文件的名称为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件a.out。 -fPIC 生成位置无关代码。 -I/home/baochen/anaconda3/include/python3.8 -I/home/baochen/anaconda3/lib/python3.8/site-packages/pybind11/include .cpython-38-x86_64-linux-gnu.so 案例分析：pybullet-planning中的ikfast编译件 我们考察如何将一个新的机械臂添加到pybullet-planning中。 首先考察已有的franka_panda机械臂，文件夹内容如下： setup.py内容如下： 调用的compile文件如下： 基本上就是传入模块名称和cpp文件的路径，然后构建出一个python可以调用的模块。 同目录的ik.py提供了一个向python暴露的接口，其中的IKFastInfo是一个namedtuple，其实就是指定了我们编译出来的模块名字(setup.py中的robot_name和compile_ikfast中的module_name)","link":"/2021/10/15/pybind11/"},{"title":"pybullet-planning源码解析","text":"我们尝试来阅读一下pybullet-planning中和ik、planning相关的源码。 我们尝试从test_franka.py入手 首先是start_pose是起始的关于tool_link的6D位姿，也就是得到pos, orn 同理，end_pose是对于start_pose施加了一个相对位移z=-distance(1m)以后的位置 我们可以发现，每一次移动的位置确实是沿着z轴相对位置后退0.1m(因为我们分了十步去处理后退1m的最终目标) 分析multiply的源码，有比较陌生的poses参数，单个的意思其实就是按照数组形式处理传入的不定长个参数 术语表： solve joints: 需要用来求解ik的关节。 free joints: 需要在ik计算前指定的关节，这些值在运行时是已知的，但是在ik创建的时候是未知。(not known at IK generation time) 以panda_franka为例，传入的ikfast_info为IKFastInfo(module_name=’franla_panda.ikfast_panda_arm’, base_link=’panda_link0’, ee_link=’panda_link8’, free_joints=[‘panda_joint7’])。因为panda是7个自由度的机器人，所以需要指定一个joint为free joint。 以UR5为例，传入的infast_info为IKFastInfo(module_name=’ur5.ikfast_ur5_arm’, base_link=’base_link’, ee_link=’ee_link’, free_joints=[])。因为UR5是6个自由度的机器人，所以不需要指定free joint。 link_from_name：根据name得到link id 换句话说，对于一个link，施加get_ordered_ancesters以后可以得到包括这个link在内的其祖先link 以panda为例： get_ordered_ancestors(panda, ee_link)：[0, 1, 2, 3, 4, 5, 6, 7] get_ordered_ancesters(panda, tool_link)：[0, 1, 2, 3, 4, 5, 6, 7, 8] first_joint：连接了base_link的joint prune_fixed_joints：去除掉固定的joint以后，需要纳入计算的joint。 ik_joints：[0, 1, 2, 3, 4, 5, 6] free_joints：[6] assert set(free_joints) &lt;= set(ik_joints)：保证需要设置的free_joint包含在ik_joints内。 assert len(ik_joints) == 6 + len(free_joints)：保证剔除掉free_joints后为6个自由度，比如7自由度关节的机械臂需要1个free_joint，6自由度关节的机械臂需要0个free_joint。 difference_fn是一个求差值的函数，对于普通的joint来说，是直接两个参数相减，对于circular joint会有一些特殊的计算方式，但是circular joint在代码中的定义是upper limit &lt; lower limit的情况，并且google也并没有找到什么有用的信息，考虑到我们目前使用的机器人都没有circular joint，就直接当做两个值相减就可以了。 get_length函数就是单纯的求n-范数，范数通过norm参数传进去。 其实closet_inverse_kinematics的后半部分只是在对求出来的解进行排序，找到一个各关节位姿变化的距离最小的解输出。而前半部分是通过generator = ikfast_inverse_kinematics(…..)求解得到了所有的可行解。 在研究ikfast_inverse_kinematics之前，我们先来搞懂interval_generator Np.random.uniform从一个均匀分布[0,1)中随机采样，获得d个数据 Halton sequence:Halton序列是一种为数值方法（如蒙特卡洛模拟算法）产生顶点的系列生成算法。虽然这些序列是以确定的方法算出来的，但它们的偏差很小。也就是说，在大多数情况下这些序列可以看成是随机的。Halton系列于1960年提出，当时是作为quasi-random 数字序列的一个例子。 所以unit_generator是从均匀分布[0,1)中采样d个数据。而在interval_generator这个函数中，也就是随机采样d个0~1之间的权重，传入convex_conbination中。 所以其实就是在lower和upper之间随机取d组点，如果joint lower limit = joint upper limit，那么自然就直接取相等。 所以，调用interval_generator会返回一个满足条件的joints的各个角度。 接下来，我们再来尝试搞懂ikfast_inverse_kinematics \\1. 首先import_ikfast函数会根据我们传入的ikfast_info去import对应机器人的cpp编译出来的模组，每次需要使用新的机器人时，都要准备好这件事情。 \\2. ik_joints和free_joints相对比较容易理解，上文中有提到过这件事情。 \\3. lower_limits和upper_limits就是joint的上下界，free_deltas不详。 \\4. Islice(generator, max_attempts)，迭代器generator生成max_attempt个proposal后结束 所以generator迭代器将原先的joint pose和随机数采样得到的joint pose可行解传入compute_inverse_kinematics中，会继续被传入到每个机械臂特有的ikfast cpp中，具体作用不详，在ur5的ikfast代码中，似乎是在某些条件下会使用采样数据作为某个joint的值。 在ikfast cpp的源码中，我们可以看到这样的表述Computes all IK solutions given a end effector coordinates and the free joints. pfree is an array specifying the free joints of the chain. 换句话说，我们传入的采样得到的sampled参数实际上是指定了对应free joint的本次求解中的值，因为free joint是需要我们指定的，这无可厚非。 \\5. 在传入对应参数以后，满足条件的解会yield出来，所以其实ikfast_inverse_kinematics生成了一个产生对应configuration下的ik解的迭代器。solutions = list(generator)，也就是把这些解都放进list中，因为实现传入的时候，我们保证了要么max_attempts不为INF，要么max_times不为INF，所以不会出现generator会成为一个无限长的迭代器的情况，如果max_times设大了，可能会影响实时性。 接下来，我们来考察pybullet_inverse_kinematics函数。 具体流程是调用multiple_sub_inverse_kinematics，然后最后可以得到一堆解。 它实现逻辑是这样的： 每次需要计算ik的时候，sample一些在各个joint limit范围内的整个机械臂的姿态，创建对应的subrobot，然后subrobot会以ik target pose为目标，迭代式地求解这个ik，也就是求解一次ik，set到对应位置，再求解ik……，迭代约200次，然后最后check最终的位姿和ik的target位姿的差值是不是小于某个阈值，如果小于则成功。 其中sub_robot其实就是在Pybullet环境中创建一个不考虑碰撞的、不可见的、相同pos的robot，只用来计算ik，在计算完成后，就会把sub_robot删除。 Motion-planning 首先是refine_path这个函数，这个函数比较简单，也就是传入一组waypoint（每个waypoint是joint的一组值），refine_path会在每相邻两个waypoint中插入num_steps个中间点，作为新的path。 get_extend_fn(resolution)这个函数也是返回一个函数是根据resolutions确定在两个waypoint之间需要插值几个waypoint点，resolution默认值为3度，也就是0.05弧度。然后调用之前所提到的get_refine_fn函数。resolution对于不同的joint可以设置不同的joint。 remove_redundant其实就是把位姿path中太近（2范数小于1e-3）的点移除。 模拟一下这个情况，首先把path[0]加入waypoint中，然后考察下一个path[i]。对于对于相邻的两次，考察相邻path[i - 1]-&gt;path[i]和path[i]-&gt;path[i+1]这两个向量，我们规范化后考察其方向，如果方向一致的话就不再加到waypoints中。所以相对于path是path中一些平均相距为resolution的位姿。 interpolate_joint_waypoints，也就是对给定的waypoint，通过不同joint的resolution来插值得到一个均匀resolution的waypoints的路径。并且如果其中插值的路径中检测到了碰撞，直接输出空路径。 其实也是带了碰撞检测的interpolate_joint_waypoint。碰撞检测发生在枚举waypoint的需要插值的节点上。注意和interpolate_joint_waypoints中碰撞检测的对象的区分（一个是需要插值的节点，一个是插值后的新增节点）。 可以看到机器学习分为两个阶段，比如倒数第三段，check_link_pair循环中，就是判断自己的link之间的碰撞，也就是self-collision。在倒数第二段，其实就是check我们的body和obstacles之间的collision。 关于这个函数中提供的碰撞检测，有aabb碰撞检测和pair_wise_collision碰撞检测。Aabb比较容易理解，而pair_wise_collision主要是通过枚举需要判断的两个物体之间的笛卡尔积，分别通过p.getClosestPoints是否等于0来判断。","link":"/2021/10/15/pybullet-planning/"}],"tags":[{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"moveit","slug":"moveit","link":"/tags/moveit/"},{"name":"CHOMP","slug":"CHOMP","link":"/tags/CHOMP/"},{"name":"planning","slug":"planning","link":"/tags/planning/"},{"name":"SE3353","slug":"SE3353","link":"/tags/SE3353/"},{"name":"WebService","slug":"WebService","link":"/tags/WebService/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Neo4j","slug":"Neo4j","link":"/tags/Neo4j/"},{"name":"behavior tree","slug":"behavior-tree","link":"/tags/behavior-tree/"},{"name":"compliers","slug":"compliers","link":"/tags/compliers/"},{"name":"lab","slug":"lab","link":"/tags/lab/"},{"name":"ikfast","slug":"ikfast","link":"/tags/ikfast/"},{"name":"pybullet","slug":"pybullet","link":"/tags/pybullet/"},{"name":"mmdection","slug":"mmdection","link":"/tags/mmdection/"},{"name":"segmentation","slug":"segmentation","link":"/tags/segmentation/"},{"name":"deeplearning","slug":"deeplearning","link":"/tags/deeplearning/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Camera","slug":"Camera","link":"/tags/Camera/"},{"name":"Pybind11","slug":"Pybind11","link":"/tags/Pybind11/"},{"name":"Pybullet","slug":"Pybullet","link":"/tags/Pybullet/"}],"categories":[]}